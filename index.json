[{"content":"","date":"17 September 2024","externalUrl":null,"permalink":"/slug/how-blogging/","section":"Slug","summary":"","title":"How-Blogging","type":"slug"},{"content":"","date":"17 September 2024","externalUrl":null,"permalink":"/tags/markdown/","section":"文章标签列表","summary":"","title":"Markdown","type":"tags"},{"content":"","date":"17 September 2024","externalUrl":null,"permalink":"/","section":"qlAD 的博客","summary":"","title":"qlAD 的博客","type":"page"},{"content":"","date":"17 September 2024","externalUrl":null,"permalink":"/slug/","section":"Slug","summary":"","title":"Slug","type":"slug"},{"content":"","date":"17 September 2024","externalUrl":null,"permalink":"/tags/%E5%AE%89%E5%88%A9/","section":"文章标签列表","summary":"","title":"安利","type":"tags"},{"content":"","date":"17 September 2024","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%AE%A2/","section":"文章标签列表","summary":"","title":"博客","type":"tags"},{"content":" 本站所有与技术有关的文章如下（包括原创和转载）\n包括但不限于 Linux 计算机 渗透测试 编程 算法 软件工具\n","date":"17 September 2024","externalUrl":null,"permalink":"/categories/%E6%8A%80%E6%9C%AF/","section":"文章分类列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站所有与技术有关的文章如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e包括但不限于 Linux 计算机 渗透测试 编程 算法 软件工具\u003c/p\u003e","title":"技术","type":"categories"},{"content":"在撰写博客的过程中，不仅仅是内容的重要性，排版、图片、交互体验等视觉设计也同样至关重要。一个设计精美、易于阅读的博客会吸引更多读者，提升用户体验。本文将为你提供一套完整的 markdown 博客创作指南，帮助你写出既有深度又美观的博客文章。\n一、合适的写作工具 # 博客创作的第一步是选择一个方便的工具，特别是如果你使用的是 Markdown 格式，那么一款好的编辑器能够极大提高效率。\nVSCode + Markdown 插件：VS Code 是一个强大的文本编辑器，搭配 Markdown 插件（如 Markdown All in One），可以方便地实时预览和编写 Markdown 内容。 Typora：Typora 是一款简单易用的 Markdown 编辑器，支持即时预览，所见即所得，适合撰写和调整排版。 MarkText：另一款优秀的 Markdown 编辑器，界面简洁，支持多种样式和实时预览。 以下是对比 VSCode、Typora 和 MarkText 这三款工具用于撰写 Markdown 的功能对比：\n功能/工具 VSCode Typora MarkText 界面风格 可高度自定义 默认即支持多种主题 界面简洁 实时预览 需要插件支持 所见即所得 所见即所得 扩展功能 丰富的插件支持 专注 Markdown 支持部分扩展功能 性能表现 插件过多时会影响速度 启动和运行流畅 启动和运行流畅 导出格式 通过插件导出各种格式 HTML、PDF 等多种格式 HTML、PDF 等多种格式 跨平台支持 Windows, macOS, Linux Windows, macOS, Linux Windows, macOS, Linux 费用 免费 商业化计划 开源免费 三者对比来看，VSCode 的自定义性和扩展性最强，适合开发者和需要强大 Markdown 扩展功能的用户。Typora 和 MarkText 则更适合注重简洁、轻便、所见即所得编辑体验的用户，且它们无需额外配置插件，直接支持常见的 Markdown 功能。\n二、适合的博客引擎 # 博客引擎是博客的核心，它负责博客的展示、评论、搜索、统计等功能。以下是一些常用的博客引擎：\nHugo + Blowfish：Hugo 是一款快速、简洁的静态网站生成器，Blowfish 是一款基于 Hugo 的博客主题。 Hexo + NexT：Hexo 是一款快速、简洁的静态网站生成器，NexT 是一款基于 Hexo 的博客主题。 Gatsby + Gatsby-theme-blog：Gatsby 是一款快速、简洁的静态网站生成器，Gatsby-theme-blog 是一款基于 Gatsby 的博客主题。 Jekyll + Minimal Mistakes：Jekyll 是一款快速、简洁的静态网站生成器，Minimal Mistakes 是一款基于 Jekyll 的博客主题。 以上博客引擎都可以快速搭建博客，并提供丰富的主题和插件支持。选择合适的博客引擎，可以让你的博客拥有更好的性能、可扩展性和可定制性。\n三、写作风格、优化排版，提升可读性 # 一篇好的博客不仅要有清晰的逻辑和内容，还要有优质的排版。以下是我使用的文章正文排版：\n导言：文章的开头，通常会有一段无格式导言，用来帮助读者快速了解文章的目的或主题。 章节：用 ### 划分主要章节，格式为：一、xxx。用 #### 来细分内容，格式为：1、xxx。 段落：每段保持在 150 字以内，避免过长的段落。 字体效果： 粗体：用于强调全文中重要的词汇。 斜粗体：用于强调或次要强调段落中的一个短语或一句话。 列表： 无序列表：用于列举短文本或无序信息。 有序列表：用于列举长文本或有序信息。 表格：用于展示结构化数据，便于对比和分类。 图片：用于分解大量文字信息，更具吸引力。 链接：帮助读者快速跳转到其他相关文章或网站。 引用：用于需要强调一段文字，或引用外部文献、经典语句，或对某个观点进行强调。 代码： 行内代码：用于展示短小的代码片段。 代码块：用于展示长代码段，并提供语法高亮。 分隔线：用于分隔超长文章中的不同段落或内容。 参考：文章末尾需提供参考链接式的文献列表，帮助读者快速了解相关背景知识。 四、合理设置文章元数据 # 文章信息是博客文章的重要组成部分，它包含了文章的标题、摘要、关键词、分类、标签、作者信息、发布时间等。根据不同的平台，信息的呈现方式也不同。下面是我的 hugo + blowfish 博客的文章信息配置：\n1、Front Matter 配置： # --- title: \u0026#34;怎么写好技术博客\u0026#34; authors: [\u0026#34;qlAD\u0026#34;, \u0026#34;ChatGPT\u0026#34;] categories: [\u0026#34;技术\u0026#34;] tags: [\u0026#34;markdown\u0026#34;, \u0026#34;安利\u0026#34;, \u0026#34;博客\u0026#34;] slug: \u0026#34;how-blogging\u0026#34; summary: \u0026#34;本文介绍了如何写好技术博客，包括博客的构架、内容、格式等。\u0026#34; series: [\u0026#34;Markdown\u0026#34;] series_weight: 1 seriesNavigation: true draft: false date: 2024-09-17T12:00:00+08:00 --- 可以搭配 VScode 的 fittencode AI 插件，自动生成一些条目，如作者、分类、标签、摘要等。\n标题：标题应简短、明确，突出文章的中心主题。 作者信息：帮助读者了解作者的经历、工作、兴趣爱好等。 分类：使文章分门别类，便于归类和检索。在我所有的博文一共三个分类，分别是技术、日常、笔记。 标签：帮助读者快速找到相关类型的文章。 slug：文章的 URL 路径，建议使用英文，便于 SEO。 摘要：一段简短的文章概括，应突出文章的核心观点，用于搜索引擎和 giscus 评论显示。 系列：将一系列相关文章组织成系列，便于用户快速了解系列内容。 系列权重：系列权重决定了文章在系列中的位置，数值越小，文章越靠前。 系列导航：开启系列导航后，用户可以快速跳转到系列中的其他文章。 草稿：草稿文章不会被发布，可以用来保存草稿、撰写中、待发布等。 发布时间：发布时间是文章的重要信息，可以帮助读者了解文章的最新动态。 2、blowfish 文章元数据配置： # 所有文章放在 content/blog 目录，以分类为名新建文件夹，然后在分类文件夹中新建一个文章 slug 同名的文件夹，再在该文件夹中存放 index.md featured.jpg backgroud.jpg 等文件。\n. ├── Daily │ └── my-home │ ├── background.jpg │ ├── featured.png │ └── index.md ├── Notes │ └── math-01-01 │ ├── background.jpg │ ├── featured.png │ └── index.md └── Technology └── algorithm-00 ├── background.jpg ├── featured.png └── index.md 其中 index.md 文件中包含了文章的正文内容，featured.jpg 和 background.jpg 是文章的封面图和背景图。\n封面图制作工具： Coverview\n背景图来源： Unsplash\n五、适当的超文本内容 # 一些超文本内容可以让你的博客不再单调，提升了用户体验的同时，还能更好的传达信息。比如插图、动画、视频、音频、表情符号、图标等。\n1、图表 # 图表是数据可视化的重要工具，它们能帮助你更直观地呈现数据。可以增强文章的视觉效果，帮助读者快速理解内容。\nExcalidraw：手绘风格的开源工具，适合绘制思维导图、流程图等。\nMermaid：基于 Markdown 的流程图工具，可以生成流程图、时序图等。Blowfish 也可以使用 mermaid\nblowfish 主题：可以使用 chart 来插入图表，原理用了 Chart.js 来生成图表。\n2、视频动画 # 和图表相比，视频动画更能传达信息，更能突出重点。能够增强文章的视觉效果，帮助读者更直观地理解内容。\nPeek：GIF 录用工具，可以录制 GIF 动画。\nYouTube 引用 ：blowfish 主题提供了此功能，可以直接嵌入 YouTube 视频。\n{{\u0026lt; youtubeLite id=\u0026#34;SgXhGb-7QbU\u0026#34; label=\u0026#34;Blowfish-tools demo\u0026#34; \u0026gt;}} 哔哩哔哩视频引用：点击对应视频的分享按钮，选择“嵌入”，复制代码到你的文章中。\n\u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?isOutside=true\u0026amp;aid=113056592037960\u0026amp;bvid=BV1VeHFeTEjo\u0026amp;cid=25675958438\u0026amp;p=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 3、代码及公式 # 代码和公式是技术博客不可或缺的组成部分。代码可以方便地展示代码片段，公式可以更直观地呈现数学公式。如果你的博客主题支持代码高亮和公式渲染，那么就可以直接在文章中使用。如果没有则手动添加以下工具。\nHighlight.js：开源的代码高亮工具，支持多种语言和样式。\ndef hello_world(): print(\u0026#34;Hello, World!\u0026#34;) KaTeX：高效的数学公式渲染工具，支持 LaTeX 语法，可嵌入博客。\n$$\\frac{d}{dx} \\left( \\int_{a}^{x} f(t),dt \\right) = f(x)$$\n4、表情符号和图标 🎉 # 除了图表、视频动画、代码、公式，添加一点表情符号和图标也可以增强文章的趣味性。\nEmojipedia：提供丰富的 Emoji 表情，可以让你的文章更具趣味性。 emojiall.com：表情符号大全，可以搜索到各种各样的表情符号。 Font Awesome：提供丰富的开源图标，可以让你的博客视觉效果更加丰富。 5、一些交互式组件 # 这里的组件指得是一些文章卡片、引用卡片、小牌子、小按钮。他们可以增强文章的互动性，提升用户的参与度。以下是一些示例，没有说明就默认是 blowfish 主题的组件，更详细的说明请看 blowfish 主题的文档。\n另一篇文章卡片：\nDAY 8 算法零基础入门 16 September 2024\u0026middot;2855 字\u0026middot;6 分钟 技术 Cs-08 C/C\u0026#43;\u0026#43; 编程 计算机专业 算法 交互按钮：\nCall to action 仓库卡片：\nnunocoracao/blowfish Personal Website \u0026amp; Blog Theme for Hugo HTML 1375 386 额外图片信息：\n图片来源 Hello 算法 小牌子： https://shields.io/\n六、SEO 优化与可发现性 # 这部分是关于博客提升在搜索引擎中的排名县官的设置，因为其内容与本篇主题相关性不大，所以仅仅提出几点建议。想了解更多，请参考 SEO 优化相关的资料。\n标题：标题应明确，突出文章的中心主题。 摘要：一段简短的文章主题概括，太长不想读，太短不够吸引人。 slug：文章的 URL 路径，建议使用英文，确保有逻辑并且保持简洁。 七、提升用户体验 # 除了丰富文章内容，提升用户体验还需考虑以下几个方面入手：\n页面加载速度：确保图片、视频和其他多媒体资源经过压缩，优化页面加载速度。\n响应式设计：确保博客在不同设备（如手机、平板电脑）上都有良好的显示效果。\n分享和评论功能：\n大部分主题都自带分享功能，如 Blowfish 主题的分享按钮。但是选择一个好的评论系统可以让作者更容易管理评论，提升互动性，增加用户参与度，提升文章质量。以下是一些评论系统的选择：\ngiscus：一个基于 GitHub Discussions 的评论系统，可以让用户在文章中直接进行评论。 utterances：一个基于 GitHub Issues 的评论系统，可以让用户在文章中直接进行评论。 disqus：一个第三方评论系统，可以让用户在文章中直接进行评论。 搜索功能：增加搜索功能，让读者可以快速找到相关文章。\n八、定期维护与更新 # 检查过时的内容：定期检查文章是否有需要更新的信息，保持内容的新鲜度和准确性。 添加最新的参考资料：更新参考文献或外部链接，确保读者可以获取最新的信息。 ","date":"17 September 2024","externalUrl":null,"permalink":"/how-blogging/","section":"文章列表","summary":"本文介绍了如何写好技术博客，包括博客的构架、内容、格式等。","title":"如何写一篇优秀的博客","type":"blog"},{"content":"","date":"16 September 2024","externalUrl":null,"permalink":"/tags/c/c-/","section":"文章标签列表","summary":"","title":"C/C++","type":"tags"},{"content":"","date":"16 September 2024","externalUrl":null,"permalink":"/series/cs/","section":"系列文章列表","summary":"","title":"CS","type":"series"},{"content":"","date":"16 September 2024","externalUrl":null,"permalink":"/slug/cs-08/","section":"Slug","summary":"","title":"Cs-08","type":"slug"},{"content":"你没看错，这么快就要学习算法了，虽然我们的 C 语言基础还不够扎实，但是我们可以先从一些基本概念和算法入门的前置知识开始。\n在实际讨论时，我们通常会将 “数据结构与算法” 简称为 “算法”。\n第一次听说算法？ # 在高中阶段，我们就已经学习过算法框图，但是那个时候我们还没有接触到计算机，所以并没有真正理解算法的概念。\n算法的定义 # 算法（Algorithm）是指用来解决特定问题的一系列指令，它是指令的有序集合，是指一系列操作，一步一步地解决一个问题。\n在计算机程序中，算法常常与数据结构联系在一起，算法是指用来解决特定问题的指令集合，而数据结构则是指用来存储和组织数据的集合。\n简单理解就是：算法是对数据进行 增删改查 的方法。数据结构是程序的骨架，而算法则是程序的灵魂。\n数据结构 # 还没开始学呢，就冒出来了一个看起来很高级的新词：数据结构。\n数据结构 是计算机存储、组织数据的方式，它是指数据 元素 的集合、关系和规则，以及这些数据元素之间的相互关系。\n举个简单的例子：\n整型 int 型数据，它可以存储整数，一堆整型数据组成的集合叫作 数组，数组就是一种数据结构。\nint scores[10] = {85, 90, 78, 88, 95, 82, 79, 91, 76, 84}; 显而易见数组有更多的优势：\n数据量大时，可以快速访问任意元素； 数组可以动态调整大小，方便添加或删除元素； \u0026hellip;\u0026hellip; 办法总比困难多 # 解决一个问题，肯定不止一种办法，写程序也是一样。\n算法优劣对比 # 不同的算法在不同的场景下，有着不同的优势。那么如何衡量一个算法的优劣呢？\n—— 用时少、花费小\n举个例子：\n从上海到北京，有多种交通工具可以选择。假设你要选择最快捷的交通工具，你会怎么做？\n第一种方法：坐飞机。 第二种方法：坐高铁。 第三种方法：坐长途汽车。 结合用时少，花费小的原则对以上方法进行对比：\n方法 用时 花费 优势 劣势 坐飞机 2-3小时 700-2000元 用时最少 费用最高 坐高铁 4.5-6小时 550-1200元 用时较短，费用适中 相对飞机稍慢 坐长途汽车 12-15小时 300-500元 费用最低 用时最长 坐飞机：最快，但价格较高且流程较为复杂。 坐高铁或火车：时间适中，价格也较合理，适合大多数人。 坐长途汽车：费用最少，但需要忍受较长的旅途时间。 没有最好的算法，只有最合适的算法。\n对于一个 有钱并且赶时间 的人来说，飞机可能最适合他。\n对于一个喜欢沿途风景的 旅行者 来说，高铁或火车可能更合适。\n对于一个 贫穷 的人来说，坐长途汽车可能是最经济的选择。\n在程序中也是一样，每个人的电脑配置不同，需求也不同，所以算法的选择也可能有所不同。\n算法与程序 # 虽然算法多种多样，但程序都有着共同的目标：解决问题。算法的目标是解决问题，所以算法的设计者往往会考虑众多因素：\n在计算机程序中一个算法应该考虑的往往是：\n正确性：正确性是指算法能够满足具体问题的需求，程序运行正常，无语法错误，能够通过典型的软件测试，达到预期的需求。 可读性：可读性指的是算法遵循标识符命名规则，简洁易懂，注释语句恰当，方便自己和他人阅读，便于后期修改和调试。 健壮性：健壮性指的是算法对非法数据以及操作有较好的反应和处理。 当然除了以上三个目标，好的算法还会考虑到其他因素：\n就是上边提到的 用时少、花费小，算法的设计者也会考虑到算法的效率。\n在计算机中所代表的就是所需运行时间更少（时间复杂度更低）、占用内存空间更小（空间复杂度更低）。\n生活中的算法 # 其实在接触计算机和编程之前，我们就已经在生活中使用算法了。比如：\n查字典（二分查找法） # 图片来源 Hello 算法 从 数据结构 的角度，我们可以把字典视为一个已排序的 “数组”；从 算法 的角度，我们可以将上述查字典的一系列操作看作 “二分查找”。\n斗地主（插入排序法） # 图片来源 Hello 算法 上述整理扑克牌的方法本质上是 “插入排序” 算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。\n比如：C++ 标准库中的 std::list::sort()\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; // For std::list int main() { // Create a list of integers std::list\u0026lt;int\u0026gt; myList = {12, 11, 13, 5, 6}; // Sort the list using the list\u0026#39;s sort() method myList.sort(); std::cout \u0026lt;\u0026lt; \u0026#34;Sorted list: \u0026#34;; for (int num : myList) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 那数据结构呢 ？ # 在生活中也可以看到数据结构的影子。比如：\n你有一个书架，书架上放着很多书籍，你按照某种顺序（例如按字母顺序或按大小）排列这些书籍。\n书架与数据结构的对应关系：\n书架上的每本书 就像数据结构中的 元素。 书架的排列顺序 类似于数据结构中元素的 顺序，比如数组或链表。 添加新书 相当于在数据结构中插入新元素。 取一本书 就像在数据结构中访问特定的元素。 移走一本书 就是删除数据结构中的一个元素。 \u0026hellip;\u0026hellip; 在书架的例子中：\n如果你按照书籍的大小从小到大排列，那就像是一个 排序数组。 如果你将书架设计成可以灵活插入和移除书籍，那么它就像一个 链表，每本书可以随意插入和移除，位置也可以动态调整。 设计算法 # 设计算法简单来说就是设计一个工作流。\n自己设计排序 # 假设你有一副扑克牌，点面全是数字，你想把这副牌按照数字大小排序，你会怎么做？\n对于一个小数组：[3, 1, 4, 1]，我们要用刚才提到的插入排序法进行排序。\n开始排序：从第二个元素 1 开始排序。\n保存当前元素：将 1 保存到 key 变量中。\n寻找插入位置：\n向前检查第一个元素 3，因为 3 \u0026gt; 1，所以需要把 3 移到右边。\n移动元素：\n将 3 移到右边，变成 [3, 3, 4, 1]。\n插入当前元素：\n把 key（1）放到前面，变成 [1, 3, 4, 1]。\n继续处理下一个元素：\n对下一个 4 执行相同操作，最后数组变成 [1, 3, 4, 1]，继续处理最后一个 1。\n最终，整个数组变成 [1, 1, 3, 4]，这是经过插入排序后的结果。\n用 C 语言来实现上述步骤：\n#include \u0026lt;stdio.h\u0026gt; // 插入排序函数 void insertionSort(int arr[], int n) { int i, key, j; for (i = 1; i \u0026lt; n; i++) { key = arr[i]; j = i - 1; // 移动元素，将大于 key 的元素移到右边 while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } } // 打印数组 void printArray(int arr[], int size) { int i; for (i = 0; i \u0026lt; size; i++) printf(\u0026#34;%d \u0026#34;, arr[i]); printf(\u0026#34;\\n\u0026#34;); } int main() { int arr[] = {3, 1, 4, 1}; int n = sizeof(arr) / sizeof(arr[0]); printf(\u0026#34;Original array: \\n\u0026#34;); printArray(arr, n); insertionSort(arr, n); printf(\u0026#34;Sorted array: \\n\u0026#34;); printArray(arr, n); return 0; } 写完之后，相见恨晚。 # 有的编程语言已经提供了现成的排序算法，比如 Python。\narr = [3, 1, 4, 1] arr.sort() print(arr) 为什么要学习算法？ # 如上文提到的 Python 的 sort() 方法、 C++ 标准库中的 std::list::sort() 就是例子。既然有了现成的算法，为什么还要自己设计一个呢？\n自己会在学习和设计过程中感觉到快乐愉悦。 自己设计的算法可以更好地满足需求。 自己设计的算法可以深入理解算法的原理。 为了比赛拿奖，为了刷题，为了面试，为了面试官的面试技巧。 作为一名程序员，通常情况下会优先使用封装好的库函数来解决问题，尤其是在库函数能够高效、可靠地满足需求时。这是因为库函数通常经过优化和广泛测试，可以提高开发效率并减少错误。\n学习 \u0026amp; 练习算法 # 算法：搜索、查找、排序、双指针、回溯、分治、动态规划、贪心、位运算、数学。\n数据结构：数组、栈、队列、字符串、链表、树、图、堆、哈希表。\nLeetCode # LeetCode 是一个算法学习网站，提供了大量的算法题目，可以用来训练自己的算法能力。\nLeetCode 官网 LeetCode 算法题库 算法竞赛 # 算法竞赛是程序员的必修课，也是衡量一个程序员水平的重要标准。\nACM 竞赛 # 蓝桥杯 # 蓝桥杯是一个算法竞赛，由蓝桥杯官方举办，主要面向高校学生。\n以下是蓝桥杯第十五届比赛的大纲：\n关于备考蓝桥杯，可以参考官方教程：\n蓝桥杯大赛章程 蓝桥杯比赛大纲 C 语言简明教程 蓝桥杯大赛历届真题 ","date":"16 September 2024","externalUrl":null,"permalink":"/cs-08/","section":"文章列表","summary":"这篇文章主要介绍算法的一些基本概念和算法入门的前置知识。","title":"DAY 8 算法零基础入门","type":"blog"},{"content":"","date":"16 September 2024","externalUrl":null,"permalink":"/tags/%E7%BC%96%E7%A8%8B/","section":"文章标签列表","summary":"","title":"编程","type":"tags"},{"content":"","date":"16 September 2024","externalUrl":null,"permalink":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/","section":"文章标签列表","summary":"","title":"计算机专业","type":"tags"},{"content":"","date":"16 September 2024","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"文章标签列表","summary":"","title":"算法","type":"tags"},{"content":" 题目来源： 《C 语言实例》 的本人改编\n1. Hello, World! # 在控制台输出 \u0026ldquo;Hello, World!\u0026quot;。\n示例：\n输入：无\n输出：Hello, World!\n2. 整数的平方 # 用户输入一个整数，输出其整数的平方；若为零，输出 “该数为零”。\n示例：\n输入：5\n输出：25\n输入：-3\n输出：9\n输入：0\n输出：该数为零\n3. 字符的 ASCII 码 # 用户输入一个字符，输出该字符的 ASCII 码。如果字符为字母，还需要判断其是大写字母还是小写字母。\n示例：\n输入：A\n输出：65, 大写字母\n输入：a\n输出：97, 小写字母\n4. 浮点数输出 # 用户输入一个浮点数和一个精度值 n，输出该浮点数，保留 n 位小数。\n示例：\n输入：3.1415926 3\n输出：3.142\n5. 两数相加 # 用户输入两个 int 整数，输出它们的和。如果加法操作导致溢出，提示“溢出错误”。\n示例：\n输入：2147483647 1\n输出：溢出错误\n输入：5 7\n输出：12\n6. 两数相乘 # 用户输入两个浮点数，输出它们的乘积，并根据结果的大小自动保留不同的精度：若乘积大于 1000，保留一位小数；若小于 1，保留五位小数；否则保留三位小数。\n示例：\n输入：3.14 2.71\n输出：8.504\n输入：123.45 10.5\n输出：1296.2\n7. 两数相除 # 用户输入两个整数，输出它们的商。\n示例：\n输入：10 0\n输出：不能除以零\n输入：10 3\n输出：3\n8. 比较排序 # 用户输入三个整数，按从大到小的顺序输出这三个数。\n示例：\n输入：5 7 3\n输出：7 5 3\n9. 交换两个数的值 # 用户输入两个整数，交换它们的值\n示例：\n输入：5 7\n输出：7 5\n10. 判断奇数/偶数 # 用户输入一个整数，并根据不同情况输出不同的结果：若为偶数，输出其平方；若为奇数，输出其立方。\n示例：\n输入：7\n输出：343\n输入：4\n输出：16\n11. 范围内的奇数 # 用户输入一个整数 n，输出 1 到 n 范围内的奇数，同时过滤掉能被 3 整除的数。\n示例：\n输入：10\n输出：1 5 7\n12. 最大的质数 # 用户输入三个整数，输出其中最大的质数。\n示例：\n输入：5 7 9\n输出：7\n13. 闰年 # 用户输入一个年份，判断该年份是否为闰年。如果不是，输出下一个最近的闰年。\n示例：\n输入：2021\n输出：不是闰年，下一个闰年是 2024\n14. 正/负/零 # 用户输入一个整数。对于正数，输出其平方；对于负数，输出其绝对值；若为零，输出提示信息。\n示例：\n输入：-5\n输出：5\n输入：3\n输出：9\n输入：0\n输出：该数为零\n15. 转换大小写 # 用户输入一个字符。如果是大写字母，将其转换为小写；如果是小写字母，将其转换为大写；否则提示输入不是字母。\n示例：\n输入：A\n输出：a\n输入：1\n输出：输入不是字母\n16. 自然数之和 # 用户输入一个整数 n，输出 1 到 n 的自然数之和，并输出每一步的加法过程。\n示例：\n输入：5\n输出：1 + 2 + 3 + 4 + 5 = 15\n17. 九九乘法表 # 输出标准的九九乘法表\n示例：\n输入：无\n输出：\n1x1=1 1x2=2 2x2=4 1x3=3 2x3=6 3x3=9 1x4=4 2x4=8 3x4=12 4x4=16 1x5=5 2x5=10 3x5=15 4x5=20 5x5=25 1x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36 1x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49 1x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64 1x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81 18. 最大公约数 # 用户输入两个整数，求它们的最大公约数。\n示例：\n输入：12 18\n输出：6\n19. 阶乘 # 用户输入一个整数 n，输出 n 的阶乘值。如果结果超过 int 类型的上限，提示 “阶乘结果溢出”。\n示例：\n输入：5\n输出：120\n输入：10\n输出：3628800\n输入：20\n输出：阶乘结果溢出\n20. 位数 # 用户输入一个整数，输出该数的位数，并依次输出每一位的数字。\n示例：\n输入：12345\n输出：5 位数\n每位数字：1 2 3 4 5\n21. n 次方 # 用户输入一个整数 n，计算并输出 n 的 n 次方。\n示例：\n输入：3\n输出：27\n22. 因数分解 # 用户输入一个整数 n，判断该整数是否为素数。若不是，输出其质因数分解。\n示例：\n输入：12\n输出：不是素数，质因数分解：2 * 2 * 3\n23. 表格 # 输出一个 10x10 的表格，表格内容为从 1 到 81 的整数，同时第 10 行和第 10 列的数字为前 9 行和前 9 列的和，（10，10）那一位的数字为第 10 行与第 10 列的现有数字的平均数。\n示例：\n输入：无\n输出：\n1 2 3 4 5 6 7 8 9 45 10 11 12 13 14 15 16 17 18 126 19 20 21 22 23 24 25 26 27 207 28 29 30 31 32 33 34 35 36 288 37 38 39 40 41 42 43 44 45 369 46 47 48 49 50 51 52 53 54 450 55 56 57 58 59 60 61 62 63 531 64 65 66 67 68 69 70 71 72 612 73 74 75 76 77 78 79 80 81 693 333 342 351 360 369 378 387 396 405 369 24. 四则运算 # 用户输入一个包含加、减、乘、除和括号的表达式，计算并输出结果。\n示例：\n输入：3 + (4 * 2) / 5\n输出：4\n25. 素数之和 # 用户输入一个整数，判断该数是否可以表示为两个素数之和，若可以，输出所有可能的组合。\n示例：\n输入：10\n输出：\n3 + 7\n5 + 5\n输入：2\n输出：不能表示为两个素数之和\n","date":"15 September 2024","externalUrl":null,"permalink":"/cs-07-test/","section":"文章列表","summary":"本文是 C 语言基础语法 50 题的题库。","title":"C 语言基础语法 25 题","type":"blog"},{"content":"","date":"15 September 2024","externalUrl":null,"permalink":"/slug/cs-07-test/","section":"Slug","summary":"","title":"Cs-07-Test","type":"slug"},{"content":"","date":"15 September 2024","externalUrl":null,"permalink":"/tags/%E9%A2%98%E5%BA%93/","section":"文章标签列表","summary":"","title":"题库","type":"tags"},{"content":"","date":"12 September 2024","externalUrl":null,"permalink":"/slug/cs-07/","section":"Slug","summary":"","title":"Cs-07","type":"slug"},{"content":" 在前面的讨论中，我们探讨了编程语言的十大通用概念。为了更深入地理解这些概念，本文将通过实际的代码示例来帮助你更好地掌握它们。\n简单回顾 # 编程的本质 # 编程的本质是通过 编写和组织代码，以实现计算机按照特定逻辑和步骤执行任务。这涉及到使用编程语言与计算机沟通，管理和处理数据，并控制程序的执行流程。编程的基础构件包括编程语言、数据结构和控制流，它们共同作用以实现功能并解决问题。\n程序的本质 # 程序的本质是由 数据和算法构成 的，数据是程序处理的信息，算法则是处理这些数据的具体步骤和方法。程序通过将数据和算法结合起来，执行特定的操作或任务，从而实现功能和解决问题。理解数据和算法的相互作用是编写高效、功能强大的程序的关键。\n编程语言的通用概念 # 序号 名称 解释 1 变量 存储数据的基本单位，用于引用和操作值。 2 数据类型 定义变量可以存储的数据类型，如整型、浮点型等。 3 控制结构 通过条件和循环语句控制程序的执行流程。 4 函数 封装可重用代码块的机制，用于执行特定任务。 5 操作符 执行运算的符号，如加法、减法等。 6 输入/输出 与外部环境交互的方式，如读取输入和输出结果。 7 错误处理 处理程序运行时出现的异常情况的机制。 8 注释 对代码进行解释的文字，不影响程序的执行。 9 作用域 变量或函数在程序中的可见范围。 10 模块化 将代码分解成独立的模块以提高代码的组织性和可维护性。 预备知识积累 # 老朋友 —— 冯·诺依曼 # 计算机是一种电子设备，因此只能识别两种基本状态：通电和断电。在最初的 ENIAC 计算机中，程序是通过大量开关和连接电线来设置的。这种方式导致每次修改程序都需要花费大量时间来重新设置开关状态和电线连接。\n为提高效率，工程师们开始探索将程序和数据存储在存储器中的方法。数学家 冯·诺依曼提出了这一思想，并将其系统化，形成了存储程序计算机模型，即冯·诺依曼架构。这一模型使得计算机能够更加灵活和高效地处理程序和数据。\n他通过 0 和 1 来表示计算机能够识别的断电和通电两种状态，所有计算机识别的指令和存储的数据都是由这两种二进制状态组成的。\n啊？指令、机器码 \u0026amp; 汇编 # 指令 是计算机处理器能够识别和执行的操作命令。指令可以告诉处理器执行某个特定的操作，比如算术运算（加法、减法）、数据传输（从内存读取数据或将数据写入内存）、逻辑操作（AND、OR）、控制流操作（跳转、调用子程序）等\n以下是不同架构（x86/x86-64 和 ARM）常见指令的简化分类表：\n类别 x86/x86-64 指令 ARM 指令 数据传输指令 MOV LDR 算术运算指令 ADD ADD 逻辑运算指令 AND AND 控制流指令 JMP B 系统调用指令 INT SVC 机器码 是指令的具体编码，由一串二进制数字组成的。但是直接用二进制表示机器码既冗长又不易理解。为了简化，程序员和开发人员通常用十六进制来表示这些机器码。\n以下是用机器码打印 hello world 的示例\n那为什么不直接用十进制呢？\n十六进制：每个十六进制数字可以表示 4 位二进制数。例如，十六进制的 0xF 对应二进制的 1111。这样，一个字节（8 位）可以用两个十六进制字符来表示，这使得机器码的表示更加紧凑和简洁。\n十进制：每个十进制数字只能表示 4 位二进制数的部分（从 0 到 9），因此要表示一个字节（8 位）的机器码，可能需要更多的数字（例如，从 0 到 255 的值）。\n示例：\n十六进制表示: 0x90 代表机器码中的 NOP 指令（No Operation），它在二进制中是 10010000，这是一个字节的表示方式。\n十进制表示: 144 是十六进制 0x90 的十进制表示。但在机器码中，直接使用 0x90 更为简洁和易读。\n汇编语言 是机器码的助记符表示，便于人类阅读和编写。\n它不是第一个编程语言，但它是第一个能够直接操作计算机硬件，同时提供一些编程便捷性的语言。\n以下是用汇编语言打印 Hello Word 的示例\nsection .data msg db \u0026#39;Hello, World!\u0026#39;, 0x0A ; 字符串数据，包含换行符 len equ $ - msg ; 计算字符串长度 section .text global _start _start: ; 写入消息到标准输出 mov eax, 4 ; 系统调用号 (sys_write) mov ebx, 1 ; 文件描述符 (stdout) mov ecx, msg ; 指向消息的指针 mov edx, len ; 消息长度 int 0x80 ; 调用内核 ; 退出程序 mov eax, 1 ; 系统调用号 (sys_exit) xor ebx, ebx ; 退出码 0 int 0x80 ; 调用内核 总结：\n指令 是高层次的概念，表示要执行的操作。 机器码 是指令的具体编码，是由操作码和操作数组成的二进制表示。 汇编语言 是机器码的助记符表示，便于人类阅读和编写。 计算机：汇编语言（完了，读不懂） \\(\\to\\) 机器码（欧耶，我的大脑可以看懂）\n编译器 \u0026amp; 解释器 ？ # 编译器是一种将 源代码（用编程语言编写）转换为 目标代码（通常是机器码或字节码）的程序。目标代码可以直接在计算机上运行，CPU 根据机器码执行相应的指令，而不需要再解释。 与之对应就有解释器\n解释器是一种逐行读取、分析和执行源代码的程序。它将源代码逐条翻译为机器码并立即执行，而不生成可执行文件。\n二者对比\n属性 编译器 (Compiler) 解释器 (Interpreter) 执行方式 一次性将源代码转换为机器码 逐行解释和执行源代码 产出 可执行文件 直接运行源代码，不生成可执行文件 执行速度 快，因为已转换为机器码 慢，因为需要逐行解释 错误检测 在编译阶段捕获语法和语义错误 在运行时捕获错误 平台依赖性 平台依赖，编译后的文件通常不能跨平台使用 通常跨平台，只需在目标平台上有相应的解释器 调试速度 编译时间较长，但运行快 无需编译，调试更方便但运行慢 还分高低贵贱 ？ # 刚开始学可能会听过编程语言的 “高级” 和 “低级”，但那并不是指语言的 “高低贵贱” 。它们是用来描述语言抽象层次的术语：\n高级语言：接近人类自然语言，更易读、易写、易理解，适合用于开发应用程序，如 Python、Java、JavaScript 等。高级语言通过编译器或解释器转换为机器代码来执行。\n低级语言：更接近机器语言，直接与硬件交互，如汇编语言和机器语言。低级语言的编程更复杂，但可以提供更高的执行效率和更精确的硬件控制。\n因此，“高级”和“低级”只是指抽象层次和对硬件的接近程度，而不是语言的优劣。\n为什么偏偏选 C 语言？ # 它是了解其它语言底层实现原理必备语言\nC语言之所以被认为是了解其他编程语言底层原理的必备语言，是因为：\n接近计算机硬件：C 语言很 “接地气”，它能直接跟计算机硬件 “对话”。学会了 C 语言，你就能理解计算机是怎么管理内存、怎么处理数据的，这些东西是很多其他编程语言看不见的 “幕后工作”。\n操作系统的语言：很多操作系统，比如 Windows 和 Linux，都是用 C 语言写的。所以，学 C 语言就像是在学习这些操作系统的 “母语”，能帮你更好地理解它们是怎么运作的。\n很多语言的 “老祖宗”：C 语言就像是很多现代编程语言的 “老祖宗”。很多编程语言，比如 C++、Java、Python，都是基于 C 语言发展起来的。如果你懂 C 语言，你就能更容易地理解这些语言的规则和用法。\n能写出高效的程序：用C语言写的程序往往更快，因为它允许你直接控制计算机的资源（比如内存）。如果你想知道为什么一些程序运行得这么快，学习 C 语言会很有帮助。\n理解内存和指针：C 语言让你直接管理计算机的内存，这是大多数其他语言不允许你做的事情。通过学习 C 语言，你可以理解计算机是如何 “记住” 和 “存储” 数据的，这在理解其他语言的运行原理时非常有用。\n总的来说，学习 C 语言就像是在学习计算机的 “母语”，它能帮助你深入理解计算机的运作方式，明白其他语言是怎么在它的基础上构建起来的。\n环境搭建 # 要想成功运行你的 C 语言程序需要写代码的程序、编译代码的程序\n编辑器：记事本、word、vscode\n编译器：GCC、clang\n而 IDE （集成开发环境）二者都有\nWindows # 不要使用 VSCode 或者 Visual Studio\n由于只是入门课，所以不需要 复杂 或者 庞大 的工具来编写。甚至可以说整个大学期间都用不上。\n这里推荐 DevC++ 这款工具，界面简单，不需要配置编译器，适合初学者。\n最新版本为 6.3，选择带 编译器 的版本下载安装。\nLinux # 由于已经掌握了 Linux 基础，Linux 不用安装 任何软件即可开始写代码。\n第一个 C 程序 # 和众多教程一样，先打个小怪\n#include \u0026lt;stdio.h\u0026gt; // 我的第一个 C 语言程序 int main() { printf(\u0026#34;Hello, World! \\n\u0026#34;); return 0; } 编译阶段 # 预处理阶段：\n编译器首先会处理预处理指令 #include \u0026lt;stdio.h\u0026gt;，它会将标准输入输出库 stdio.h 的内容包含到当前源代码中。stdio.h 库定义了 printf 函数等标准输入输出函数的原型和宏定义。\n注释处理：\n编译器会忽略注释部分 // 我的第一个 C 语言程序。注释的目的是帮助程序员理解代码，编译器在编译时会将其忽略。\n语法分析：\n编译器会从上到下分析代码的语法结构。首先，它会看到 int main()，这是程序的主入口函数。编译器知道它应该在这里开始执行程序。\n语义分析和符号表生成：\n在语法分析通过后，编译器会进行语义分析。它会检查 printf 函数的调用是否正确，并确保参数和返回类型匹配。它会检查所有变量和函数的声明和定义。\n生成中间代码：\n编译器接着生成中间代码或抽象语法树，这些中间表示形式是后续优化和机器码生成的基础。\n代码优化：\n编译器可能会进行一些优化，例如删除多余的指令，简化表达式，或在 printf 的调用中优化字符串的处理方式。\n生成目标代码：\n最后，编译器将中间代码转化为目标代码（机器码），并生成可执行文件。\n执行阶段 # 程序入口 main()：\n执行从 main 函数开始。\n调用 printf 函数：\nprintf(\u0026quot;Hello, World! \\n\u0026quot;); 会将字符串 Hello, World! 输出到标准输出（通常是屏幕）。printf 函数会将格式化字符串参数发送给操作系统，以显示到控制台。\n返回值 return 0;：\nreturn 0; 表示程序成功执行，返回代码 0 通常表示程序正常退出，任何非零值通常表示异常退出。\n总结 # 包含头文件： #include \u0026lt;stdio.h\u0026gt; 表示引入标准输入输出库的头文件，其中包含了 printf 函数的声明。 注释： // 我的第一个 C 语言程序 是一个单行注释，用于提供对程序的简要描述。 main 函数： int main() 是程序的入口点。 printf 函数： printf(\u0026quot;Hello, World! \\n\u0026quot;); 是一个输出语句，它将字符串 “Hello, World!” 和一个换行符打印到标准输出设备（通常是控制台）。 返回值： return 0; 表示 main 函数成功执行并正常结束，返回值为 0。在 C 语言中，返回值为 0 通常表示程序成功执行。 通用概念在 C 的体现 # 为了方便理解和演示，我会以：\n注释 \\(\\to\\) 输入/输出 \\(\\to\\) 变量 \\(\\to\\) 数据类型 \\(\\to\\) 操作符 \\(\\to\\) 控制结构 \\(\\to\\) 函数 \\(\\to\\) 模块化 \\(\\to\\) 作用域 \\(\\to\\) 错误处理\n的顺序进行讲解\n注释 # 注释是在所有计算机语言中都非常重要的一个概念，可以用来解释某一段程序或者某一行代码是什么意思，方便程序员之间的交流沟通。\n注释的类型有单行注释和多行注释\n1. 单行注释 # 单行注释前加 // // 单行注释 2. 多行注释 # 多行注释用 /**/ 包裹起来 /* xxxxxx 多行注释 xxxxxx */ 3. 嵌套注释 # 注释可以嵌套，如下： #include \u0026lt;stdio.h\u0026gt; // 我的第一个 C 程序。 // 这是一个嵌套的单行注释 /* 这是一个嵌套的多行注释 */ /* main 函数是 C 语言程序的入口点，程序从这里开始执行。 int main() 函数的返回值是 int 类型，一般情况下，返回 0 表示程序执行成功，非 0 表示程序执行失败。 // 这是一个嵌套的单行注释 */ int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); // printf() 函数用于输出到屏幕 return 0; } 注意：多行注释不能嵌套多行注释\n输入/输出 # 输入/输出是指程序与外部世界（如用户、文件、网络等）进行交互的过程。\n1. 工具箱 stdio.h # 在 C 语言中，输入和输出（I/O）操作是程序与外部世界（如用户、文件、网络等）进行交互的基本方式。标准输入输出（Standard input and output）库 stdio.h 提供了多种函数来实现这些操作。\n这个文件在 /usr/include 目录下\n2. 输出工具 printf # printf （format）函数用于格式化输出到标准输出（屏幕）。\n用法：printf(format_string, arg1, arg2,..., argn)\nformat_string：格式化字符串，包含了输出内容的格式和顺序。 arg1, arg2,\u0026hellip;, argn：格式化参数，用于填充格式字符串中的占位符。 例如：printf(\u0026quot;Hello, %s!\\n\u0026quot;, \u0026quot;world\u0026quot;);\n3. 输入工具 scanf # scanf （format）函数用于格式化从标准输入（键盘）读取输入。\n用法：scanf(format_string, arg1, arg2,..., argn)\nformat_string：格式化字符串，包含了输入内容的格式和顺序。 arg1, arg2,\u0026hellip;, argn：格式化参数，用于填充格式字符串中的占位符。 例如：scanf(\u0026quot;%d %s\u0026quot;, \u0026amp;num, str);\n4. 示例： # #include \u0026lt;stdio.h\u0026gt; int main() { // 定义一个整型变量 num 和一个字符数组 str，用于存储字符串，最大长度为100 int num; char str[100]; printf(\u0026#34;Enter a number: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); // 读取一个整数 printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, str); // 读取一个字符串 printf(\u0026#34;You entered: %d and %s\\n\u0026#34;, num, str); // 输出结果 return 0; } 变量 # 变量是程序中用于存储数据的内存位置。\n1. 基本数据类型 # 数据类型 描述 示例值 int 整型变量 25, -100, 0 float 浮点型变量 5.9, -3.14, 0.0 char 字符型变量 'A', 'b', '9' 2. 定义变量 # 变量的声明：数据类型 变量名 ; 变量的初始化：数据类型 变量名 = 初始值; 3. 变量的命名规则 # 变量名只能包含字母、数字和下划线。 变量名的第一个字符不能是数字。 变量名的大小写敏感。 变量名不能与关键字冲突。 变量名的长度不能超过 31 个字符。 int num; // 声明一个整型变量 num float pi = 3.14; // 声明一个浮点型变量 pi，并初始化为 3.14 char ch = \u0026#39;a\u0026#39;; // 声明一个字符型变量 ch，并初始化为 \u0026#39;a\u0026#39; C 中的关键字： auto break case char const continue \u0026hellip;\n4. 示例 # #include \u0026lt;stdio.h\u0026gt; int main() { // 整型变量 int a = 10; int b = 20; int c = a + b; printf(\u0026#34;The sum of %d and %d is %d\\n\u0026#34;, a, b, c); // 浮点型变量 float d = 3.14; printf(\u0026#34;The value of pi is %f\\n\u0026#34;, d); // 字符型变量 char e = \u0026#39;A\u0026#39;; printf(\u0026#34;The ASCII value of %c is %d\\n\u0026#34;, e, e); return 0; } 5. 奇怪的 % # %d 、%f 和 %c 这三个格式化符号，它们的意义和作用都很奇怪。\n%d：打印整数。 %f：打印浮点数。 %c：打印字符。 数据类型 # 数据类型是指变量所存储的数据的类型。\n1. 基本数据类型补充 # 类型 存储大小 取值范围 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 float 4 字节 1.2E-38 到 3.4E+38 char 1 字节 -128 到 127 或 0 到 255 我们可以通过 sizeof() 函数来获取数据类型的存储大小。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; int main() { printf(\u0026#34;int 存储大小 : %lu \\n\u0026#34;, sizeof(int)); return 0; } 除此之外还有：\n整数类型\n类型 存储大小 值范围 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 unsigned char 1 字节 0 到 255 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 浮点类型\n类型 存储大小 值范围 double 8 字节 2.2E-308 到 1.8E+308 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;float.h\u0026gt; int main() { printf(\u0026#34;float 存储最大字节数 : %lu \\n\u0026#34;, sizeof(float)); printf(\u0026#34;float 最小值: %E\\n\u0026#34;, FLT_MIN ); printf(\u0026#34;float 最大值: %E\\n\u0026#34;, FLT_MAX ); printf(\u0026#34;精度值: %d\\n\u0026#34;, FLT_DIG ); return 0; } 输出\nfloat 存储最大字节数 : 4 float 最小值: 1.175494E-38 float 最大值: 3.402823E+38 精度值: 6 %E 格式化符号用于输出浮点数，其中 E 表示指数形式。\n除了刚才讲的基本数据类型（整型、浮点型、字符型）外还有：\n指针类型：void *、int *、float *、char * 结构体类型：struct 枚举类型：enum 操作符 # 操作符是用来执行特定操作的符号。\n1. 算术运算符 # 其中算术运算符有：+、-、*、/、%\n举例：\nint a = 20; int b = 10; int c = a + b; // 加法运算 int d = a - b; // 减法运算 int e = a * b; // 乘法运算 int f = a / b; // 除法运算 int g = a % b; // 取模运算 输出：\n输入两个整数 a 和 b: 3 2 a + b = 5 a - b = 1 a * b = 6 a / b = 1 a % b = 1 2. 赋值运算符 # 赋值运算符有：=、+=、-=、*=、/=、%=\n举例：\nint a = 20; int b = 10; a += b; // a = a + b a -= b; // a = a - b a *= b; // a = a * b a /= b; // a = a / b a %= b; // a = a % b 3. 关系运算符 # 关系运算符有：==、!=、\u0026gt;、\u0026gt;=、\u0026lt;=\n举例：\nint a = 20; int b = 10; printf(\u0026#34;%d == %d? %d\\n\u0026#34;, a, b, a == b); // 等于 printf(\u0026#34;%d!= %d? %d\\n\u0026#34;, a, b, a!= b); // 不等于 printf(\u0026#34;%d \u0026gt; %d? %d\\n\u0026#34;, a, b, a \u0026gt; b); // 大于 printf(\u0026#34;%d \u0026gt;= %d? %d\\n\u0026#34;, a, b, a \u0026gt;= b); // 大于等于 printf(\u0026#34;%d \u0026lt; %d? %d\\n\u0026#34;, a, b, a \u0026lt; b); // 小于 printf(\u0026#34;%d \u0026lt;= %d? %d\\n\u0026#34;, a, b, a \u0026lt;= b); // 小于等于 4. 逻辑运算符 # 逻辑运算符有：||、\u0026amp;\u0026amp;、!\n和关系运算一样逻辑运算的结果也只有 0 或 1。\n举例：\nint a = 10; int b = 20; printf(\u0026#34;%d\u0026#34;, a \u0026gt; 0 \u0026amp;\u0026amp; b \u0026lt; 30); // 输出 1 printf(\u0026#34;%d\u0026#34;, a \u0026gt; 0 || b \u0026gt; 30); // 输出 1 printf(\u0026#34;%d\u0026#34;,!(a \u0026gt; 10)); // 输出 0 控制结构 # 控制结构是程序的执行流程的控制语句。\n1. 条件语句：if # 条件语句是用来判断条件是否成立，并根据条件的成立与否执行不同的代码块。\n条件语句的语法：\nif (条件表达式) { // 条件表达式为 true 时执行的代码块 } else { // 条件表达式都不成立时执行的代码块 } 示例：\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 10; int y = 20; if (x == y) { printf(\u0026#34;%d is equal to %d\\n\u0026#34;, x, y); } else { printf(\u0026#34;%d is not equal to %d\\n\u0026#34;, x, y); } return 0; } 2. 循环语句：for # 循环语句是用来重复执行代码块的语句。\n循环语句的语法：\nfor (初始化表达式; 条件表达式; 迭代表达式) { // 循环体 } 示例：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i; for (i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return 0; } 疑问：i++ 和 ++i 有什么区别？\n答案：i++ 是后置递增，而 ++i 是前置递增。\n示例：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = 5; int a, b; // 后置递增 i++ a = i++; // 先将 i 的值（5）赋给 a，然后 i 增加 1（i 变为 6） printf(\u0026#34;After a = i++, i: %d, a: %d\\n\u0026#34;, i, a); // 输出：i: 6, a: 5 // 重置 i i = 5; // 前置递增 ++i b = ++i; // 先将 i 增加 1（i 变为 6），然后将 i 的值（6）赋给 b printf(\u0026#34;After b = ++i, i: %d, b: %d\\n\u0026#34;, i, b); // 输出：i: 6, b: 6 return 0; } 3. 跳转语句：goto # 跳转语句是用来改变程序执行流程的语句。\n跳转语句的语法：\ngoto 标签名; 示例：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; while (i \u0026lt; 5) { i++; if (i == 3) { goto end; // 跳转到 end 标签处 } printf(\u0026#34;%d\\n\u0026#34;, i); } end: // 定义 end 标签 printf(\u0026#34;The end\\n\u0026#34;); return 0; } 函数 # 函数是程序中用来执行特定功能的子程序。\n1. 函数的声明 # 返回类型 函数名 (参数类型 参数名) {函数体}\n示例：\n定义一个比大小的函数：\nint compare(int a, int b) { if (a \u0026gt; b) { return 1; } else if (a \u0026lt; b) { return -1; } else { return 0; } } 2. 函数的调用 # 调用方式：函数名 (参数1, 参数2, ...)\n示例：\n#include \u0026lt;stdio.h\u0026gt; int compare(int a, int b) { if (a \u0026gt; b) { return 1; } else if (a \u0026lt; b) { return -1; } else { return 0; } } int main() { int x = 10; int y = 20; int result = compare(x, y); // 调用函数 if (result == 1) { printf(\u0026#34;%d is greater than %d\\n\u0026#34;, x, y); } else if (result == -1) { printf(\u0026#34;%d is less than %d\\n\u0026#34;, x, y); } else { printf(\u0026#34;%d is equal to %d\\n\u0026#34;, x, y); } return 0; } 模块化 # 模块化是指将一个大型程序分解为多个小模块，每个模块只完成特定的功能，然后再将这些模块组合起来组成一个完整的程序。\n1. 头文件 # 头文件是模块化的重要组成部分。头文件中包含了模块的接口（函数声明），模块的实现（函数定义）和全局变量声明。\n头文件以 .h 结尾，包含了模块的接口。\n示例： 新建 my_header_file.h 文件\n// 声明一个求和的函数 int sum(int a, int b) { return a + b; } 2. 示例： # #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;my_header_file.h\u0026#34; // 包含头文件 int main() { int x = 10; int y = 20; int z = sum(x, y); // 调用函数求和 printf(\u0026#34;The sum of %d and %d is %d\\n\u0026#34;, x, y, z); return 0; } 作用域 # 作用域是程序中变量、函数、结构体等符号的可访问范围。\n1. 简单说明 # 定义在所有函数之外的变量，称为全局变量，可以被所有函数访问。 定义在函数内部的变量，称为局部变量，只能在函数内部访问。 以下是全局作用域和局部作用域的区别\n作用域 变量类型 访问范围 全局作用域 全局变量 在程序的任何位置都可以访问 全局函数 在程序的任何位置都可以调用 局部作用域 局部变量 只能在定义它的函数体内访问 局部函数 只能在定义它的函数体内调用 示例：\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 10; // 局部变量 int y = 20; // 局部变量 { int x = 30; // 局部变量 int y = 40; // 局部变量 printf(\u0026#34;x = %d, y = %d\\n\u0026#34;, x, y); } printf(\u0026#34;x = %d, y = %d\\n\u0026#34;, x, y); return 0; } 2. 还有高手 # 当局部变量被定义时，系统不会对其初始化 ，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化 ，如下所示：\n变量类型 初始值 int 0 float 0.0 char \u0026lsquo;\\0\u0026rsquo; 错误处理 # 错误处理是指程序在运行过程中出现错误时，如何处理错误。\n错误类型：\n错误类型分为：语法错误、逻辑错误、运行时错误。\n错误处理机制：\n语法错误：编译器在编译时就发现错误，并报告错误信息。 逻辑错误：运行时发现错误，程序会终止运行。 运行时错误：运行时出现错误，程序会终止运行。 示例：\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 10; int y = 0; int z = x / y; // 运行时错误，程序会终止运行 printf(\u0026#34;The result is %d\\n\u0026#34;, z); return 0; } 总结 # 本文主要介绍了 C 语言的一些基本概念，包括注释、输入/输出、变量、数据类型、操作符、控制结构、函数、模块化、作用域、错误处理等。\n剩下的进阶内容，如指针、结构体、枚举、数组、指针运算、字符串、文件操作等，将在后续的文章中介绍。\n","date":"12 September 2024","externalUrl":null,"permalink":"/cs-07/","section":"文章列表","summary":"这篇文章介绍了 C 语言的基本语法，包括变量声明、控制结构和函数定义等内容，适合初学者学习和参考。","title":"DAY 7 C 语言基础语法","type":"blog"},{"content":"","date":"12 September 2024","externalUrl":null,"permalink":"/slug/submit_baidu_index/","section":"Slug","summary":"","title":"Submit_baidu_index","type":"slug"},{"content":"","date":"12 September 2024","externalUrl":null,"permalink":"/tags/%E5%B7%A5%E5%85%B7/","section":"文章标签列表","summary":"","title":"工具","type":"tags"},{"content":" 在现代网站开发中，确保搜索引擎能够迅速收录新发布的内容是至关重要的。百度作为主要的搜索引擎之一，为了优化网站的搜索引擎排名，我们需要定期提交网站的更新。本文将介绍如何使用 GitHub Actions 自动提交百度收录，实现自动化的内容更新通知。\n目标 # 通过配置 GitHub Actions 实现以下目标：\n提取 sitemap.xml 文件中的所有 URL：从 sitemap.xml 文件中提取出所有需要提交的 URL。 提交 URL 到百度：将提取的 URL 通过 API 提交到百度，以确保搜索引擎能及时更新网站内容。 步骤概览 # 创建 Bash 脚本：编写一个脚本来提取 URL 并提交到百度。 配置 GitHub Actions：设置 GitHub Actions 工作流以在每次推送到主分支时自动运行该脚本。 创建 Bash 脚本 # 首先，我们需要创建一个 Bash 脚本，用于从 sitemap.xml 中提取 URL 并将其提交到百度。\n1. 编写 submit_urls.sh 脚本 # 在项目的 scripts 目录下创建 submit_urls.sh 文件，内容如下：\n#!/bin/bash # Use the provided sitemap path or default path SITEMAP_PATH=${1:-\u0026#34;../public/zh-cn/sitemap.xml\u0026#34;} # Ensure BAIDU_API_URL is set if [ -z \u0026#34;$BAIDU_API_URL\u0026#34; ]; then echo \u0026#34;Error: The BAIDU_API_URL environment variable is not set.\u0026#34; exit 1 fi # Check if the sitemap file exists if [ ! -f \u0026#34;$SITEMAP_PATH\u0026#34; ]; then echo \u0026#34;Error: Sitemap file not found at $SITEMAP_PATH.\u0026#34; exit 1 fi # Extract all URLs from sitemap.xml and save them to urls.txt echo \u0026#34;Extracting URLs from sitemap.xml...\u0026#34; grep -oP \u0026#39;(?\u0026lt;=\u0026lt;loc\u0026gt;).*?(?=\u0026lt;/loc\u0026gt;)\u0026#39; \u0026#34;$SITEMAP_PATH\u0026#34; \u0026gt; urls.txt URL_COUNT=$(wc -l \u0026lt; urls.txt) echo \u0026#34;Extracted $URL_COUNT URLs and saved them to urls.txt.\u0026#34; # Use curl to submit all URLs in urls.txt to Baidu echo \u0026#34;Submitting URLs to Baidu...\u0026#34; response=$(curl -s -H \u0026#39;Content-Type:text/plain\u0026#39; --data-binary @urls.txt \u0026#34;$BAIDU_API_URL\u0026#34;) # Print the response from the curl command echo \u0026#34;Response from Baidu: $response\u0026#34; echo \u0026#34;Submission completed!\u0026#34; 2. 确保脚本可执行 # 通过以下命令为脚本赋予可执行权限：\nchmod +x scripts/submit_urls.sh 配置 GitHub Actions # 接下来，我们需要设置 GitHub Actions 工作流，以便在每次推送到主分支时自动运行 submit_urls.sh 脚本。\n1. 创建 GitHub Actions 工作流配置文件 # 在 .github/workflows 目录下创建一个新的 YAML 文件，比如 submit_urls.yml，内容如下：\nname: Submit URLs to Baidu on: push: branches: - main jobs: submit-urls: runs-on: ubuntu-latest steps: - name: Check out the repository uses: actions/checkout@v2 - name: List files for debugging run: ls -R - name: Submit URLs to Baidu env: BAIDU_API_URL: ${{ secrets.BAIDU_API_URL }} # Securely reference the secret run: ./scripts/submit_urls.sh \u0026#34;./public/zh-cn/sitemap.xml\u0026#34; 2. 配置 GitHub Secrets # 为了保护百度 API URL，您需要在 GitHub 仓库中配置一个密钥。进入仓库的 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions，添加一个新的密钥，名称为 BAIDU_API_URL，并填入您的百度 API URL。\n总结 # 通过上述步骤，我们配置了 GitHub Actions 自动化提交百度收录。每次将代码推送到主分支时，GitHub Actions 会自动运行 submit_urls.sh 脚本，提取 sitemap.xml 中的 URL 并将其提交到百度。这不仅简化了网站内容更新的工作流程，还确保搜索引擎能够迅速捕捉到网站的最新变化。\n希望这篇文章对你有所帮助，提升你的站点在搜索引擎中的可见性。如果有任何问题或建议，请随时留言讨论！\n","date":"12 September 2024","externalUrl":null,"permalink":"/submit_baidu_index/","section":"文章列表","summary":"本文将介绍如何通过 GitHub Actions 自动提交百度收录，提高网站内容更新的效率和准确性。","title":"配置 GitHub Actions 实现自动化提交百度收录","type":"blog"},{"content":"","date":"12 September 2024","externalUrl":null,"permalink":"/tags/%E8%BD%AF%E4%BB%B6/","section":"文章标签列表","summary":"","title":"软件","type":"tags"},{"content":"","date":"9 September 2024","externalUrl":null,"permalink":"/slug/cs-06/","section":"Slug","summary":"","title":"Cs-06","type":"slug"},{"content":" 编程语言看似复杂，但它们背后的核心概念其实与我们所学的数学、物理、逻辑等知识有很多相似之处。理解这些通用概念，可以帮助我们更容易地学习任何一种编程语言（如Python、JavaScript、Java、C++等）。以下，我将结合所学知识来解释编程中的这些基本概念。\n1. 变量 # 变量即是数据的存储单元\n编程中的变量：\n在编程中，变量是存储数据的命名位置。它们就像是一个可重用的 标签，可以指向不同的 数据（例如数字、字符串、对象等）。\n类比：\n在数学中，变量是一个可以表示任意值的字母或符号。例如，方程 x = 5 中，x 是一个变量，表示一个值为 5 的数。\n用途：\n变量用于存储程序中的临时数据、用户输入、计算结果等。\n示例：\nage = 25 # 在Python中，age是一个变量，表示年龄 2. 数据类型 # 数据类型即变量的属性\n编程中的数据类型：\n数据类型决定了变量的 内存大小 和 允许的操作 。常见的数据类型有整数、浮点数、字符串、布尔值等。\n类比：\n类似于数学中数的类型，比如整数、分数、实数等。在编程中，不同的数据类型有不同的特性和用途。\n用途：\n数据类型帮助程序了解如何处理和操作数据，以及如何进行内存管理。\n示例：\ntemperature = 36.5 # 浮点型 is_student = True # 布尔型 3. 控制结构 # 控制结构即程序的决策和流程控制\n编程中的控制结构：\n控制结构用于控制程序的 执行流程，例如条件判断（if-else）、循环（for, while）等。\n类比：\n在生活中，我们会根据条件做决定，比如 “如果下雨，我就带伞，否则不带伞”。这类似于编程中的条件语句。\n用途：\n控制结构让程序根据不同条件执行不同的代码块，或者重复执行某些代码。\n示例：\nif score \u0026gt;= 60: print(\u0026#34;Pass\u0026#34;) else: print(\u0026#34;Fail\u0026#34;) 4. 函数 # 函数即可重用的代码块\n编程中的函数：\n函数是将 代码封装 成可重复使用的 独立单元，用来执行特定任务或计算。函数可以接受输入（参数），执行操作，并返回结果。\n类比：\n类似于数学中的函数，如 f(x) = x + 2，给定 x，函数会返回一个值。\n用途：\n函数提高了代码的复用性和可读性，减少了重复代码，使代码更易于管理。\n示例：\ndef add(a, b): return a + b 5. 操作符 # 操作符即数据的操作工具\n编程中的操作符：\n操作符是用于执行各种操作的符号，如算术运算（+、-）、逻辑判断（\u0026amp;\u0026amp;、||）、比较（==、!=）等。\n类比：\n类似于数学中的运算符，比如 +、-、*、/，它们用于执行计算。\n用途：\n操作符是程序中的基本计算工具，帮助实现各种数据运算和逻辑判断。\n示例：\nsum = 3 + 2 # 使用+操作符进行加法计算 6. 输入/输出 # 输入/出即程序与外界的沟通交互桥梁\n编程中的输入/输出：\n输入/输出（I/O）用于与用户或其他系统交互，接受输入数据或输出结果。\n类比：\n类似于做实验时的输入和输出：输入是控制变量（如温度），输出是观察到的结果（如反应速度）。\n用途：\n输入/输出使得程序能够动态接受用户的输入并显示相应的结果。\n示例：\nname = input(\u0026#34;Enter your name: \u0026#34;) # 输入 print(f\u0026#34;Hello, {name}!\u0026#34;) # 输出 7. 错误处理 # 处理错误即应对异常情况的机制\n编程中的错误处理：\n错误处理用于捕获和处理程序运行中的异常情况，避免程序崩溃。例如，尝试除以零或访问不存在的文件。\n高中类比：\n在数学解题时，如果发现某个操作（如分母为零）是不允许的，就需要进行特殊处理。\n用途：\n错误处理确保程序能够在异常情况下优雅地处理错误，增强了程序的健壮性。\n示例：\ntry: result = 10 / 0 except ZeroDivisionError: print(\u0026#34;Cannot divide by zero\u0026#34;) 8. 注释 # 注释即代码的解释和说明\n编程中的注释：\n注释是对代码的解释或说明，不会被编译或执行。注释对代码的理解、维护和团队协作非常重要。\n类比：\n类似于在作业本旁边的批注，用于解释解题思路或提醒自己注意事项。\n用途：\n注释提高了代码的可读性，帮助开发者和维护者理解代码逻辑。\n示例：\n# 这是单行注释 9. 作用域 # 作用域即变量的可见范围\n编程中的作用域：\n作用域决定了变量和函数的可访问范围。局部变量只在其定义的块中可用，而全局变量在整个程序中可访问。\n类比：\n类似于物理中的局部和全局视野：局部变量只能在特定范围内 “看见”，全局变量可以在任何地方 “看见”。\n用途：\n作用域限制了变量的可见性和生存期，防止命名冲突和数据意外修改。\n示例：\nglobal_var = 10 # 全局变量 def function(): local_var = 5 # 局部变量 10. 模块化 # 模块化即组织和重用代码的方式\n编程中的模块化：\n模块化将程序划分为 多个独立的部分（模块或文件），使得代码更易于组织、理解和维护。\n类比：\n类似于一本书的多个章节，每个章节讲述一个特定的主题，有助于读者的理解和参考。\n用途：\n模块化提高了代码的重用性、可读性和维护性，便于大型项目的开发和扩展。\n示例：\n# 引入自定义模块 import my_module 结论 # 编程语言的这些核心概念是相互关联的，就像构建房屋的砖块。通过这些高中知识的类比，我们可以更加直观地理解编程语言的基础概念。无论学习哪种编程语言，理解这些基本概念都是迈向编程大师之路的第一步。\n希望这篇文章能够帮助你更好地理解和学习编程。下一次，当你遇到一个新的编程概念时，不妨试着用你所学的知识去类比它，说不定会豁然开朗呢！\n通过这样的类比，我们可以更轻松地理解编程语言的核心概念，并应用于学习和实践中。\n","date":"9 September 2024","externalUrl":null,"permalink":"/cs-06/","section":"文章列表","summary":"本文介绍了编程语言的核心概念，包括变量、数据类型、控制结构、函数、操作符、输入/输出、错误处理、注释、作用域、模块化等。","title":"DAY 6 编程语言的核心概念","type":"blog"},{"content":"","date":"9 September 2024","externalUrl":null,"permalink":"/slug/cs-05/","section":"Slug","summary":"","title":"Cs-05","type":"slug"},{"content":" 编程，作为科技时代的重要工具之一，似乎总是带着一种神秘的光环。很多人觉得编程只有专业人士才能掌握，充满了晦涩的代码和复杂的数学计算。实际上，编程的核心并不神秘，它是一种与计算机对话的方式，帮助我们解决现实生活中的问题。今天，我们将从零基础的角度来探索编程的本质，了解其背后的逻辑和思维方式。\n一、编程是什么？ # 编程，其实就是用一种计算机可以理解的语言，告诉计算机去完成一系列任务。\n打个比方，这就像你在教一个新手如何做一道菜。你会详细地告诉他每一步该怎么做：先洗菜，再切菜，然后热锅，最后烹饪。\n同样地，编程也是把复杂的任务分解成简单的步骤，然后通过指令让计算机去执行。\n在这个过程中，编程语言就像是沟通的桥梁，把人类的思维转换成计算机能够理解的“语言”。这些语言有特定的语法和规则，它们帮助我们有效地传达指令，就像说一门外语一样。\n二、编程的本质 # 编程的本质在于解决问题。\n无论是开发一个网站、制作一款游戏，还是设计一个财务管理系统，所有这些编程活动的背后都有一个共同点，那就是解决问题。要解决问题，首先需要了解问题是什么，接着制定一个详细的计划，最后一步一步地执行计划。这就是编程所做的事情。\n编程的整个过程可以分解为以下几个关键步骤：\n明确问题：清晰地理解需要解决的问题是什么。 分解任务：将大问题分解成多个小任务，这样更容易一步一步地解决。 设计方案：为每个小任务设计一个解决方案。可以通过画流程图、写伪代码等方法来规划解决方案。 实现方案：用编程语言将设计的解决方案翻译成计算机可以理解的指令。 测试和优化：反复测试代码，找出错误并进行优化，直到问题彻底解决。 这个过程就像搭积木一样，需要一步一步搭建，最后完成一个完整的作品。\n三、编程的思维方式 # 编程不仅仅是技术上的操作，它还包含了很多思维方式的培养，特别是逻辑思维和创造力的结合。\n逻辑思维：编程要求我们具备严密的逻辑思维能力。\n编程中的每一步都需要有明确的逻辑，比如做出条件判断（如果发生某事，则执行某操作）、处理循环（重复执行某些操作直到满足条件）等。\n就像走迷宫一样，每一步都要确保方向正确，最终才能找到出口。\n创造力：除了逻辑，编程还需要创造力。面对同一个问题，不同的人可能会有不同的解决方案。\n编程的世界没有唯一的答案，这给了我们极大的创造空间。我们可以根据自己的思考方式，设计出独特的程序和算法，让程序变得更加高效或者更具趣味性。\n四、编程的基础构件 # 编程的基础可以用三个重要的构件来概括：编程语言、数据结构和控制流。\n编程语言：编程语言是人与计算机交流的工具。\n每种编程语言都有其独特的语法和使用场景，如 Python 适合数据分析和人工智能，JavaScript 适合网页开发，C++ 则在系统编程和游戏开发中表现出色。学习编程语言的语法是入门的第一步，就像学习一门新语言需要掌握基本的语法规则一样。\n数据和数据结构：编程中，数据是核心。\n数据可以是数字、文本、图像等，编程中的一切操作都是围绕数据展开的。为了更有效地管理和处理数据，编程中使用了各种 数据结构，如数组、列表、栈、队列、哈希表等。不同的数据结构有不同的特点和使用场景，选择合适的数据结构可以让程序更加高效。\n控制流：控制流决定程序的执行顺序，是编程的核心之一。\n控制流包括 条件语句（如 if-else ）、循环语句（如 for、while ）和分支语句（如 switch ），它们让程序能够在不同的条件下执行不同的代码块，或者重复执行某些代码块。掌握控制流是编写复杂程序的关键。\n五、程序的基础构件 # 程序的核心可以分为两大部分：数据 和 算法。这两者是所有程序的基础构件。数据是程序处理的信息，而算法是处理数据的步骤和方法。理解数据和算法如何相互作用，是学习编程的关键。\n数据：程序的“原材料”\n在编程中，数据是核心的组成部分。数据是程序用来存储和处理的信息，它可以是各种类型的，如数字、文本、图像等。处理数据的方式对程序的效率和功能影响巨大。因此，我们需要了解数据的基本概念和如何有效地组织和管理数据。\n数据类型：常见的数据类型包括：\n类型 描述 举例 整数 用来表示整数值 1、-5 浮点数 用来表示带小数点的数字 3.14、-0.01 字符串 用来表示文本 \u0026quot;Hello, World!\u0026quot; 布尔值 用来表示逻辑判断结果 只有两个值 true 和 false 数据结构：常见的数据结构类型包括：\n类型 描述 数组 一种线性结构，用于存储相同类型的数据 列表 类似于数组，但通常允许存储不同类型的元素 栈 队列 这两种数据结构用于特定的访问模式 哈希表 一种非线性结构 树和图 用于表示更复杂的数据关系 数据操作：对数据进行操作是编程的重要组成部分，包括读取数据、修改数据、插入数据、删除数据等。理解这些操作及其在不同数据结构中的效率，是编写高效代码的关键。\n算法：解决问题的“方法”\n算法是解决问题的具体方法和步骤。它定义了如何操作数据来实现特定的目标。算法的核心在于 逻辑思维 和 问题分解。在编程中，不同的问题会用到不同的算法，有些算法擅长处理大数据，有些算法则用于快速查找或排序。了解常见的算法可以帮助我们更高效地解决各种问题。\n排序算法：排序是最基本的操作之一，常见的排序算法有：\n冒泡排序（Bubble Sort）：一种简单的排序算法，重复地比较相邻元素并交换，直到整个序列有序。 快速排序（Quick Sort）：一种高效的排序算法，基于分治法，将数组分成小部分进行排序。 归并排序（Merge Sort）：另一种基于分治法的排序算法，通过将数组一分为二，分别排序后再合并。 搜索算法：在数据集中查找特定元素的算法，包括：\n线性搜索（Linear Search）：逐个检查每个元素，直到找到目标元素或搜索结束。 二分查找（Binary Search）：一种高效的查找算法，适用于已排序的数据，通过反复将搜索范围减半来查找目标元素。 递归与分治算法：递归是一种直接或间接调用自身的算法，适合解决可以分解为相同子问题的问题，例如：\n斐波那契数列：使用递归计算数列中的第N个数。 汉诺塔问题：经典的递归问题，通过将问题分解为更小的子问题来求解。 动态规划（Dynamic Programming）：一种将复杂问题分解为简单子问题的方法，适合用来解决最优化问题，如最短路径、最长公共子序列等。\n贪心算法（Greedy Algorithm）：一种在每一步都选择最优解的算法，适用于寻找局部最优解的问题。\n可以通过 https://visualgo.net/en 查看算法的可视化\n或者力扣的算法可视化视频 https://www.bilibili.com/video/BV1Ky4y1S7Jz/\n数据与算法的结合：程序的核心逻辑\n在编程中，数据和算法是两个不可或缺的基础构件。数据是程序的原材料，而算法是加工数据的工具。通过理解和掌握这两者，我们就能够编写出功能强大、高效稳定的程序。这不仅帮助我们解决现实问题，也能激发我们的创造力，在编程世界中自由探索和创造。\n六、学习编程的路径 # 从零开始，步步为营。学习编程的过程可以分为几个阶段，每个阶段都有不同的目标和方法。\n基础阶段：掌握基本的编程概念和语法规则。\n了解什么是变量、数据类型、条件判断、循环、函数等。这些是编程的“字母表”，是构建任何程序的基础。\n实践阶段：通过小项目练习来加强理解。\n比如，编写一个简单的计算器、制作一个猜数字游戏，或者开发一个小型的个人网站。这些项目可以帮助你将理论应用到实践中，更好地理解编程的逻辑和思维方式。\n进阶阶段：学习更高级的编程概念。\n如面向对象编程、函数式编程、算法和数据结构等。这些知识能帮助你编写更高效、更复杂的程序，解决更高级的问题。\n项目实战阶段：参与实际项目的开发。\n从需求分析、设计、编码、测试到优化，全面体验编程的完整流程。这可以是一个小组项目，也可以是为社区或开源项目做贡献。\n持续学习阶段：编程是一个需要不断学习和进步的领域。\n新的语言、工具和技术不断涌现，需要不断学习和更新知识。同时，多参与编程社区交流，了解行业趋势和最佳实践。\n七、编程的未来 # 编程不仅是一种技能，更是一种改变世界的力量。在现代社会，编程已经融入到各行各业：\n日常生活应用：从智能手机应用到智能家居，从社交媒体到在线购物平台，这些都离不开编程的支持。 前沿科技：人工智能、区块链、自动驾驶、物联网等前沿技术的背后，编程都是核心驱动力。 行业变革：编程正在改变医疗、金融、教育、制造等各个行业，通过数据分析、自动化、智能化的解决方案，提高效率和创新能力。 个人能力提升：无论你是工程师、设计师、数据分析师，还是创业者，编程都可以成为你提升职业竞争力的有力工具。 八、结语 # 编程不是一个遥不可及的领域，而是一种面向未来的技能。它帮助我们更好地理解和驾驭科技世界，也锻炼了我们的逻辑思维和创造力。希望这篇文章能让你对编程有一个更清晰的认识，鼓励你迈出学习的第一步。未来的编程世界，因你的加入而更加精彩！\n","date":"9 September 2024","externalUrl":null,"permalink":"/cs-05/","section":"文章列表","summary":"本文将从零基础的角度来探索编程的本质，了解其背后的逻辑和思维方式。","title":"DAY 5 编程先导课：揭开编程的神秘面纱","type":"blog"},{"content":"","date":"9 September 2024","externalUrl":null,"permalink":"/slug/cs_04_test/","section":"Slug","summary":"","title":"Cs_04_test","type":"slug"},{"content":"","date":"9 September 2024","externalUrl":null,"permalink":"/tags/linux/","section":"文章标签列表","summary":"","title":"Linux","type":"tags"},{"content":"1. Linux 操作系统使用下面哪个按键补齐当前正在输入的指令（ ）\nA. CTRL\nB. CTRL+ALT\nC. TAB\nD. CTRL+TAB\n2. Linux 操作系统使用下面哪个命令查看本机的IP地址（ ）\nA. ifconfig\nB. ipconfig\nC. netstat\nD. ss\n3. Linux 命令的基本语法是（ ）\nA. 命令 参数 选项\nB. 命令 选项 参数\nC. 选项 命令 参数\nD. 选项 参数 命令\n4. 以下哪项是存放 Linux 系统用户的应用程序与指令的路径（ ）\nA. /usr/log\nB. /usr/bin\nC. /var\nD. /etc\n5. 以下哪项是存放 Linux 系统日志的路径（ ）\nA. /tmp/log\nB. /var/log\nC. /usr/log\nD. /etc/log\n6. Linux 系统使用哪个命令剪切文件（ ）\nA. Ctrl+X\nB. Ctrl+C\nC. mv\nD. cp\n7. Linux 系统使用哪个命令切换工作路径（ ）\nA. cd\nB. dir\nC. is\nD. mv\n8. 以下哪项是绝对路径表示（ ）\nA. var/log\nB. /etc\nC. var/\nD. etc\n9. 在 Linux 系统中，rw-r\u0026ndash;r\u0026ndash; 权限用数字表示是（ ）\nA. 755\nB. 655\nC. 644\nD. 744\n10. Linux 系统使用哪个命令更改文件权限（ ）\nA. chmod\nB. chm\nC. chown\nD. cho\n11. Linux 系统使用哪个命令更改文件所有者（ ）\nA. chmod\nB. chm\nC. chown\nD. cho\n12. Linux系统使用哪个命令从最后一行开始向前显示文件（ ）\nA. Cat\nB. tac\nC. less\nD. more\n13. Linux 系统使用 cat 命令时，使用哪个选项显示行号（ ）\nA. N\nB. B\nC. b\nD. n\n14. Linux 系统使用哪个命令可以动态查看到文件的实时更新（ ）\nA. tail -f\nB. tail -n\nC. cat -n\nD. cat -f\n15. /etc/passwd 文件中第一列表示（ ）\nA. 用户名\nB. 用户ID\nC. 密码\nD. 组ID\n16. /etc/passwd 中第几列表示用户登录的 shell（ ）\nA. 5\nB. 6\nC. 7\nD. 8\n17. Linux 操作系统中，将用户添加的组的命令是（ ）\nA. useradd\nB. groupadd\nC. usermod\nD. useraddgroup\n18. Linux 操作系统中，使用哪个命令更改用户的主要组（ ）\nA. usermod -a\nB. usermod -g\nC. usermod -A\nD. usermod -G\n19. Linux 操作系统中，当我们输入sudo 以提升权限时，系统会要求我们输入（ ）\nA. root 的登录密码\nB. 当前用户的登录密码\nC. 一个独立的权限提升密码\nD. 不需要输入密码，直接输入 y 表示确认\n20. 以下哪个命令用于诊断到目标主机的连通性（ ）\nA. ping\nB. ss\nC. netstat\nD. ipconfig\n21. Linux 在命令后面加上什么符号，会将命令放在后台运行（ ）\nA. !\nB. $\nC. \u0026amp;\nD. #\n22. 下面哪个命令以用户角度查看进程使用资源（ ）\nA. ps -u\nB. ps -a\nC. ps u\nD. ps a\n23. Linux 在终止进程时，使用哪个命令可以直接加上进程名来终止进程？（ ）\nA. Killall\nB. kill\nC. kill -name\nD. kill pname\n24. systemctl enabled iptables 命令的含义是（ ）\nA. 启动 iptables 服务器\nB. 将 iptables 服务设为开机自动启动\nC. 查看当前 iptabesl 服务的状态\nD. 开启 iptables 服务的日志记录功能\n25. Linux 的主要特性包含（ ）【多选】\nA. 完全免费\nB. 多任务\nC. 一切皆文件\nD. 支持多平台\n26. Linux 的发行版本有（ ）【多选】\nA. aix\nB. centos\nC. ubuntu\nD. redhat\n27. 以下哪些是 /etc/shadow 文件中表示的含义（ ）【多选】\nA. 用户账户已禁用的天数\nB. 用户口令最长使用天数\nC. 用户上次修改口令日期\nD. 用户上次的口令明文\n28. Linux 中的 top 命令默认会显示下面哪些（ ）【多选】\nA. 系统运行时间\nB. 系统过去 1 分钟的平均负载\nC. 物理内存使用\nD. 系统线程数量\n29. Linux 操作系统在登录时，输入密码，系统以 * 显示密码长度。（ ）\nA. 正确\nB. 错误\n30. Linux 命令行结尾的提示符#表示，当前登录的用户是普通用户。（ ）\nA. 正确\nB. 错误\n31. / 是 Linux 所有路径的开始，简称 Linux 的根目录（ ）\nA. 正确\nB. 错误\n32. 若当前目录为 /home,命令 ls –l 将显示 home 目录下的（ ）。\nA. 所有文件\nB. 所有隐含文件\nC. 所有非隐含文件\nD. 文件的具体信息\n33. RED HAT LINUX 9 默认使用的文件系统类型为（ ）\nA. ext2\nB. ext3\nC. FAT\nD. swap\n34. 在 LINUX 中，要查看文件内容，可使用（ ）命令。\nA. more\nB. cd\nC. login\nD. logout\n35. 以下命令中，可以将用户身份临时改变为 root 的是（ ）。\nA. SU\nB. su\nC. login\nD. logout\n36. 若要将当前目录中的 myfile.txt 文件压缩成 myfile.txt.tar.gz，则实现的命令为（ ）。\nA. tar –cvf myfile.txt myfile.txt.tar.gz D.\nB. tar –zcvf myfile.txt myfile.txt.tar.gz\nC. tar –zcvf myfile.txt.tar.gz myfile.txt\nD. tar –cvf myfile.txt.tar.gz myfile.txt\n37. usermod 命令无法实现的操作是（ ）\nA. 账户重命名\nB. 删除指定的账户和对应的主目录\nC. 加锁与解锁用户账户\nD. 对用户密码进行加锁或解锁\n38. 要使得名为 fido 的文件具有如下权限 -r-xr-x—x 的命令________\n39. 在 /root 文件夹下查找后缀为 .cpp 的文件 ________\n40. 关闭 Linux 系统（不重新启动）可使用（ ）命令。\nA. ctrl+alt+del\nB. halt\nC. shutdown -r\nD. reboot\n41. 显示已经挂装的文件系统磁盘 inode 使用状况的命令是( )\nA. df –i\nB. su –I\nC. du –I\nD. free –i\n42. 将前一个命令的标准输出作为后一个命令的标准输入，称之为 ________\n43. 在使用了 shadow 口令的系统中，/etc/passwd 和 /etc/shadow 两个文件的权限正确的是：\nA. -rw-r\u0026mdash;\u0026ndash; , -r\u0026mdash;\u0026mdash;\u0026ndash;\nB. -rw-r\u0026ndash;r\u0026ndash; , -r\u0026ndash;r\u0026ndash;r\u0026ndash;\nC. -rw-r\u0026ndash;r\u0026ndash; , -r\u0026mdash;\u0026mdash;\u0026ndash;\nD. -rw-r\u0026ndash;rw- , -r\u0026mdash;\u0026ndash;r\u0026ndash;\n44. 有一个备份程序 mybackup，需要在周一至周五下午 1 点和晚上 8 点各运行一次，下面哪条 crontab 的项可以完成这项工作？\nA. 0 13,20 * * 1,5 mybackup\nB. 0 13,20 * * 1,2,3,4,5 mybackup\nC. * 13,20 * * 1,2,3,4,5 mybackup\nD. 0 13,20 1,5 * * mybackup\n45. 如何从当前系统中卸载一个已装载的文件系统\nA. umount\nB. dismount\nC. mount -u\nD. 从 /etc/fstab 中删除这个文件系统项\n46. 运行一个脚本，用户不需要什么样的权限？\nA. read\nB. write\nC. execute\nD. browse on the directory\n47. 如何快速切换到用户 John 的主目录下？\nA. cd @John\nB. cd #John\nC. cd \u0026amp;John\nD. cd ~John\n48. 使用什么命令可以查看 Linux 的启动信息？\nA. mesg -d\nB. dmesg\nC. cat /etc/mesg\nD. cat /var/mesg\n49. 如何装载 (mount) 上在 /etc/fstab 文件中定义的所有文件系统\nA. mount -a\nB. mount /mnt/*\nC. mount\nD. mount /etc/fstab\n50. 使用 ln 命令将生成了一个指向文件 old 的符号链接 new，如果你将文件 old 删除，是否还能够访问文件中的数据？\nA. 不可能再访问\nB. 仍然可以访问\nC. 能否访问取决于文件的所有者\nD. 能否访问取决于文件的权限\n","date":"9 September 2024","externalUrl":null,"permalink":"/cs_04_test/","section":"文章列表","summary":"本文是一套 Linux 笔试 50 题，主要考察候选人对 Linux 操作系统的基本使用技能。","title":"Linux 笔试 50 题","type":"blog"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/series/math/","section":"系列文章列表","summary":"","title":"Math","type":"series"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/slug/math-01-02/","section":"Slug","summary":"","title":"Math-01-02","type":"slug"},{"content":" 本站所有与笔记有关的文章如下（包括原创和转载）\n包括但不限于 高中 大学 机构 网课 读书\n","date":"8 September 2024","externalUrl":null,"permalink":"/categories/%E7%AC%94%E8%AE%B0/","section":"文章分类列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站所有与笔记有关的文章如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e包括但不限于 高中 大学 机构 网课 读书\u003c/p\u003e","title":"笔记","type":"categories"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/tags/%E9%80%BB%E8%BE%91%E7%94%A8%E8%AF%AD/","section":"文章标签列表","summary":"","title":"逻辑用语","type":"tags"},{"content":"先空着，后面写\n","date":"8 September 2024","externalUrl":null,"permalink":"/math-01-02/","section":"文章列表","summary":"本篇文章介绍了一些常用的逻辑用语。","title":"模块一 常用逻辑用语","type":"blog"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6/","section":"文章标签列表","summary":"","title":"数学","type":"tags"},{"content":"","date":"7 September 2024","externalUrl":null,"permalink":"/slug/cs_04/","section":"Slug","summary":"","title":"Cs_04","type":"slug"},{"content":" 预备知识 # Linux 简介 # Linux 诞生于 1991 年，由芬兰大学生 Linus Torvalds 开发\nLinux 操作系统是基于 Unix 以网络为核心的设计思想，是一个性能稳定的多用户操作系统，能运行各种软件工具、应用程序和网络协议，支持安装在 32 和 64 位 CPU 硬件上。\nLinux 只代表 Linux 内核，但是人们习惯用 Linux 来形容基于 Linux 内核的发行版。\nGNU 是一个自由的非营利组织，在 GNU 提供的各种工具的支持下构成了我们常说的 Linux 发行版，全称 GNU/Linux\nLinux 优点 # 开源免费 性能稳定 安全性高 多任务、多用户 节省资源 使用容易 Linux 版本 # 内核版\n内核是 Linux 系统中最基本的东西，由 Linus 领导的小组进行开发\nhttps://www.kernel.org/\n版本号：xx.yy.zz\n第一个数字：6，主版本号 第二个数字：10，次版本号 第三个数字：8，修订版本号，表示修订次数 版本类型：\n小于 2.6\n次版本号奇数为不稳定版，次版本号偶数为稳定版\n大于 2.6\n版本名称 解释 mainline 主线版本 stable 稳定版 longterm 长期支持版 linux-next 预览版 在 Linux 上可通过 uname 命令查看内核版本\nuname --all 内核版本功能：\n内存管理 进程管理 设备驱动程序 系统调用和安全防护 发行版\n发行版就是我们常说的操作系统，包括以下部分：\nLinux 内核 GNU 工具 附加软件 软件包管理器 全球大约有几千种不同的 Linux 发行版，每个发行版都有自己的特征和目标人群\n发行版 特征 目标人群 Debian 稳定、安全、软件包管理系统使用 APT；社区驱动，长期支持版本（LTS）。 服务器管理员、桌面用户、开发者 CentOS 由 Red Hat Enterprise Linux（RHEL）衍生的免费版；专注于稳定性和安全性。 企业用户、服务器管理员 Fedora 最新技术的测试平台；社区支持，短生命周期；使用 DNF 软件包管理器。 开发者、桌面用户 Arch 滚动更新、KISS（Keep It Simple, Stupid）原则；高度可定制性。 高级用户、Linux 爱好者 Kali 专为渗透测试和安全研究设计；预装大量安全工具和测试框架。 网络安全专家、渗透测试员 查看 Linux 发行版版本\n查看 /etc/os-release 文件\ncat /etc/os-release 对于 Debian 系的系统，查看 /etc/debian_version\ncat /etc/debian_version 对于 Red Hat 系的系统，查看 /etc/redhat-release\ncat /etc/redhat-release 习题 # 一、填空\nLinux 诞生于 ________ 年，由 ________ 开发。 Linux 是一个 ________ 任务 ________ 用户的操作系统。 Linux 的版本分为 ________ 和 ________ 。 Linux 的管理员账号是 ________ 。 二、选择\n下列 ________ 是自由软件。\nA. Windows XP B. UNIX C. Linux D. Windows 2000\nLinux的内核版本 2.3.20 是 ________ 的版本。\nA. 不稳定 B. 稳定的 C. 第三次修订\nD. 第二次修订\n环境准备 # VMware 虚拟机 # Debian 安装 # SSH 连接 Debian # 习题 # 一、简答\n使用虚拟机安装 Linux 时，为什么要选择稍后安装操作系统，而不是直接选择 Debian.iso 的系统映像光盘？ 怎么开启关闭 SSH 服务？ Linux 文件系统 # 磁盘是用来存储文件的，但是必须先把磁盘格式化为某种格式的文件系统，才能存储文件。\n文件系统是操作系统用于用来组织、存储、管理和检索数据的机制。负责将数据组织成文件和目录的形式，使用户和应用程序能够轻松地创建、读取、修改和删除数据。简单来说，文件系统就像是一个大型的文件柜，它帮助我们将文件和目录按需存放，并能够方便地找到和使用它们。\n文件系统类型 # 文件系统类型 描述 EXT4 第四代扩展文件系统，Linux 默认文件系统，支持大文件和分区、日志功能、延迟分配等特性。 XFS 高性能 64 位日志文件系统，支持大文件和高并发，适合处理大量数据的服务器和数据库应用。 Btrfs 现代的 CoW（写时复制）文件系统，支持快照、子卷、压缩和 RAID 功能，设计用于高可扩展性。 ReiserFS 早期的日志文件系统，具有高效的小文件存储能力，近年来由于缺乏维护和开发逐渐被淘汰。 F2FS 由三星开发的闪存文件系统，专为 NAND 闪存存储设备（如 SSD）优化，支持垃圾回收和热冷数据分离。 JFS IBM 开发的日志文件系统，具有低 CPU 使用率和快速恢复时间，适合大文件和多线程工作负载。 ZFS 具有高度可靠性和可扩展性的文件系统，支持数据完整性、压缩、快照和 RAID-Z，适用于存储服务器。 当添加新磁盘并且分区后需要进行格式化，操作系统才能够使用这个磁盘分区。格式化的目的是建立操作系统可以使用的文件系统类型。\n每种操作系统使用的文件系统类型并不相同，Windows 用 NTFS 文件系统。并且在默认情况下 Windows 不能识别 Linux 文件系统的磁盘分区。\n查看本机使用的文件系统\n使用 df 命令\ndf -hT 使用 lsblk 命令\nlsblk -f 示例输出：\n假设你使用 df -hT 命令，你可能会看到类似以下的输出：\nFilesystem Type Size Used Avail Use% Mounted on /dev/sda1 ext4 50G 30G 17G 64% / /dev/sdb1 xfs 100G 70G 25G 74% /data 这里，/dev/sda1 使用的是 ext4 文件系统，而 /dev/sdb1 使用的是 xfs 文件系统。\n目录存储结构 # 对于一个磁盘来说，在被格式化相对应的文件系统后，整个分区被分为不同的块，根据使用的不同，块还可以分为以下几种：\n超级块：存储文件系统的总体信息，包括文件系统的大小、inode 和数据块的数量、文件系统的状态等。它是文件系统操作的核心部分。 inode（索引节点）：存储文件的元数据，如权限、大小、创建时间等。每个文件在文件系统中都有一个唯一的 inode。inode 不包含文件名，文件名与 inode 的关联通过目录实现。 数据块：实际存储文件内容的区域。文件的内容被分割成多个数据块，这些块存储在磁盘上。文件系统通过 inode 来记录这些数据块的位置，以便在读取文件时能够找到这些块。 EXT4 的文件系统结构基本如下\nFHS # FHS（Filesystem Hierarchy Standard，文件系统层次结构标准） 是一套定义 Linux 和其他类 Unix 操作系统中文件和目录结构的标准。\n它规定了各个目录的用途和它们应该包含的内容，以确保文件系统结构的一致性和可移植性，使不同的应用程序和系统能够更好地协同工作。\nFHS 的优势\n标准化：通过提供一致的文件和目录结构，FHS 帮助开发者和管理员更轻松地找到文件和配置。 兼容性：遵循 FHS 的 Linux 发行版在文件路径上保持兼容性，提高了软件移植和安装的效率。 安全性和稳定性：将系统文件与用户文件、可变数据与静态数据分开，有助于系统的安全性和稳定性管理。 FHS 的目录结构\n文件系统 是底层的存储机制，负责管理和存储数据。\nFHS 是一个标准，用来定义 Linux 文件系统的目录结构和组织方式。\n绝对路径和相对路径 # 路径是一个文件的位置，绝对路径从根目录（/）开始写起，相对路径指相对于当前路径的写法。\n举例：在人民广场下车的外国人问你怎么找到厕所\n绝对路径：首先坐飞机来到中国，出机场后乘坐地铁 3 号线来到人民广场，在人民广场下车后路口左转 相对路径：左转 路径类型 优点 缺点 绝对路径 始终准确定位文件或目录位置 路径长，维护不便 脚本中使用更稳定可靠 目录结构变化时需要更新 相对路径 简短易输入，适合本地目录操作 依赖当前工作目录，易出错 目录结构变化时通常不需修改路径 跨系统时不如绝对路径明确 两个特殊的目录：\n. 表示当前目录，也可以用 ./ .. 表示上一层目录，也可以用 ../ Linux 常见命令 # Linux 是一个强大的操作系统，它提供了许多常用的命令行工具，可以帮助我们用于管理文件、目录、进程、网络和系统配置等。\n预备知识：上哪敲命令？ # 终端\n在 Linux 系统中，终端 是一个命令行界面，允许用户与操作系统进行交互。用户可以在终端中输入命令来执行各种操作，如运行程序、管理文件和配置系统。终端通常由一个文本输入区域和一个输出区域组成，其中显示命令结果和系统消息。终端是执行命令、脚本和程序的主要工具，常用于系统管理和开发工作。\n终端模拟器\n终端模拟器 是在图形用户界面（GUI）环境中模拟传统终端的应用程序。它允许用户在图形桌面上打开一个窗口，通过这个窗口来访问命令行界面。终端模拟器提供了类似于物理终端的功能，但可以在窗口中运行，支持多标签、字体调整、滚动缓冲区等高级功能。常见的终端模拟器包括 GNOME Terminal、Konsole、xterm 和 Terminator。\nLinux 系统命令行的含义：\n示例：root@app00:~# root //用户名，root 为超级用户 @ //分隔符 app00 //主机名称 ~ //当前所在目录，默认用户目录为 ~，会随着目录切换而变化 # //表示当前用户是超级用户，普通用户为 $ 如何敲一个命令 # 一个命令通常由以下部分组成：\n示例：命令 参数名 参数值 命令名：\n可以通过在线网站或手册查询能用的 Linux 命令：\nhttps://www.runoob.com/linux/linux-command-manual.html https://www.linuxcool.com/ 参数：\n同上可以通过在线网站或手册学习到 Linux 命令的所有参数\n但一般 Linux 命令都带一个帮助参数 --help 或者缩写 -h\n如果你想获得更详细的文档，可以去找那个男人 man\nman cat //man + 命令名 如果是一名合格的 Linux 用户，应该掌握如下命令：\n生存命令 # 查看当前目录（pwd）\npwd //显示当前位置路径 切换目录（cd）\ncd / //切换到根目录 cd /bin //切换到根目录下的 bin 目录 cd ../ //切换到上一级目录 或者使用命令：cd .. cd ~ //切换到 home 目录 cd xx(文件夹名) //切换到本目录下的 xx 的目录 cd /xxx/xx/x //输入绝对路径，直接切换到目标目录 查看目录（ls）\nls //查看当前目录下的所有目录和文件 ls -a //查看当前目录下的所有目录和文件（包括隐藏的文件） ls -l //列表查看当前目录下的所有目录和文件 ls /bin //查看指定目录下的所有目录和文件 查看文件（cat）\ncat a.txt //查看文件内容 head a.txt //查看文件前几行内容 tail a.txt //查看文件后几行内容 创建目录（mkdir）\nmkdir tools //在当前目录下创建一个名为tools的目录 mkdir /bin/tools //在指定目录下创建一个名为tools的目录 删除目录与文件（rm）\nrm 文件名 //删除当前目录下的文件 rm -f 文件名 //删除当前目录的的文件（不询问） rm -r 文件夹名 //递归删除当前目录下此名的目录 rm -rf 文件夹名 //递归删除当前目录下此名的目录（不询问） rm -rf * //将当前目录下的所有目录和文件全部删除 rm -rf /* //将根目录下的所有文件全部删除 提权（sudo）\nsudo vim a.txt //可用管理员编辑文件 搜索目录（find）\nfind /bin -name \u0026#39;a*\u0026#39; //查找/bin目录下的所有以a开头的文件或者目录 修改目录（mv）\nmv 当前目录名 新目录名 //修改目录名，同样适用与文件操作 mv /usr/tmp/tool /opt //将/usr/tmp目录下的tool目录剪切到 /opt目录下面 拷贝目录（cp）\ncp /usr/tmp/tool /opt //将/usr/tmp目录下的tool目录复制到 /opt目录下面 cp -r /usr/tmp/tool /opt //递归剪复制目录中所有文件和文件夹 习题 # 一、填空\n在 Linux 系统中命令 ________ 大小写。在命令行中，可以使用 ________ 键来补充命令。 如果要在一个命令行上输入和执行多条命令，可以用 ________ 来分隔命令。 要使程序以后台方式运行，只需要在命令后面跟上 ________ 符号。 ________ 代表当前目录，也可用 ./ 表示。________ 代表上一层目录，也可以用 ../ 表示。 若一个文件前多一个 “.”，则该文件是一个 ________ 。可以用 ________ 命令查看。 要查看当前所在的目录，应使用的命令是 ________ 。 用长格式使用 ls 命令列出文件和目录的命令是 ________ 。 二、选择\n如果忘了 ls 的用法，可以用 ________ 来获取帮助\nA ? ls\nB help ls\nC man ls\nD get ls\n存放 Linux 基本命令的目录是 ________\nA /bin\nB /tmp\nC /lib\nD /root\n如果当前目录是 /home/sea/china ，那么 “china” 的父目录是 ________\nA /home/sea\nB /home\nC /\nD /sea\n利用 cp 复制系统文件 /etc/profile 到当前目录下，命令是 ________\nA # cp /etc/profile /\nB # cp /etc/profile ./\nC $ cp /etc/profile ./\nD $ cp ./ /etc/profile\n三、简答\n添加参数的目的是什么？ 使用 rm 时用什么参数来避免二次确定 Linux 用户及文件管理 # Linux 是多用户多任务的操作系统，掌握用户管理至关重要。因为多用户操作，为了确保系统安全性，在安装 Linux 时必须设置 root 密码。虽然 root 用户操作不受任何限制，但能力越大责任越大，一不小心就会毁掉整个系统，虚拟机不怕。\n用户管理 # 在 Linux 中用户身份有如下：\n通过使用用户号码 UID 区分\n管理员 UID 为 0：系统的管理员用户 系统用户 UID 为 1~999：Linux 系统为了避免黑客入侵控制整台服务器，为每一个服务程序都设置一个专门的系统用户来运行，防止提权，控制破坏范围 普通用户 UID 为 1000 开始：由管理员创建的日常工作的用户。 UID 不能冲突，普通用户的 UID 如果没有自行指定，则从 1000 开始，即使 999 没人用。\n为了方便管理众多用户，而引入用户组这个概念，用用户组号码区分 GID\n用户账号的管理 # 添加新的用户账号使用 useradd 命令，其语法如下：\nuseradd 选项 用户名 删除一个已有的用户账号使用 userdel 命令，其格式如下：\nuserdel 选项 用户名 修改已有用户的信息使用 usermod 命令，其格式如下：\nusermod 选项 用户名 指定和修改用户口令的命令是 passwd。\n超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\npasswd 选项 用户名 用户组的管理 # 增加一个新的用户组使用 groupadd 命令。其格式如下：\ngroupadd 选项 用户组 如果要删除一个已有的用户组，使用 groupdel 命令，其格式如下：\ngroupdel 用户组 修改用户组的属性使用 groupmod 命令。其语法如下：\ngroupmod 选项 用户组 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。\nnewgrp 用户组 用户账号系统文件 # /etc/passwd 文件是用户管理工作涉及的最重要的一个文件。\nLinux 系统中的每个用户都在 /etc/passwd 文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n这个文件对所有用户都是可读的。它的内容类似下面的例子：\ncat /etc/passwd root:x:0:0:Superuser:/: daemon:x:1:1:System daemons:/etc: bin:x:2:2:Owner of system commands:/bin: sys:x:3:3:Owner of system files:/usr/sys: adm:x:4:4:System accounting:/usr/adm: uucp:x:5:5:UUCP administrator:/usr/lib/uucp: auth:x:7:21:Authentication administrator:/tcb/files/auth: cron:x:9:16:Cron daemon:/usr/spool/cron: listen:x:37:4:Network daemon:/usr/net/nls: lp:x:71:18:Printer administrator:/usr/spool/lp: sam:x:200:50:Sam san:/home/sam:/bin/sh 从上面的例子我们可以看到，/etc/passwd 中一行记录对应着一个用户，每行记录又被冒号 : 分隔为 7 个字段，其格式和具体含义如下：\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell\n/etc/shadow 中的记录行与 /etc/passwd 中的一一对应，它由 pwconv 命令根据 /etc/passwd 中的数据自动产生\n下面是 /etc/shadow 的一个例子：\ncat /etc/shadow root:Dnakfw28zf38w:8764:0:168:7::: daemon:*::0:0:::: bin:*::0:0:::: sys:*::0:0:::: adm:*::0:0:::: uucp:*::0:0:::: nuucp:*::0:0:::: auth:*::0:0:::: cron:*::0:0:::: listen:*::0:0:::: lp:*::0:0:::: sam:EkdiSECLWPdSa:9740:0:0:::: 它的文件格式与 /etc/passwd 类似，由若干个字段组成，字段之间用 : 隔开。这些字段是：\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n用户组的所有信息都存放在 /etc/group 文件中。\n将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段。\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。\n当一个用户同时是多个组中的成员时，在 /etc/passwd 文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n用户要访问属于附加组的文件时，必须首先使用 newgrp 命令使自己成为所要访问的组中的成员。\n/etc/group 文件的一个例子如下：\ncat /etc/group root::0:root bin::2:root,bin sys::3:root,uucp adm::4:root,adm daemon::5:root,daemon lp::7:root,lp users::20:root,sam 此文件的格式也类似于 /etc/passwd 文件，由冒号 : 隔开若干个字段，这些字段有：\n组名:口令:组标识号:组内用户列表\n用户组的口令信息在 /etc/gshadow 文件中\n/etc/gshadow 文件的一个例子如下：\ncat /etc/gshadow root:::brltty,root sys:!*::bin mem:!*:: ftp:!*:: mail:!*:: log:!*:: smmsp:!*:: proc:!*:: 此文件的格式，由冒号 : 隔开若干个字段，这些字段有：\n组名:口令:管理员用户列表:组内用户列表。\n批量添加用户 # 见我的另一篇文章\n习题 # 一、填空\nLinux 是 多 ________ 多任务的操作系统，它允许多个用户同时登录到系统，使用系统资源。 Linux 下的用户账号分为两种： ________ 和 ________ Linux 中 root 的 UID 为 ________ ，普通用户的 UID 如果不指定默认从 ________ 开始按顺序编号。 Linux 系统中用户账户及相关信息（口令除外）都放在 ________ 文件中。 所有用户对 /etc/passwd 都有 ________ 权限，为了系统安全性，加密后的口令都存放在 ________ 文件中。 组的信息都存放在 ________ 文件中，而一些信息（组口令，组成员）存放在 ________ 文件中。 二、选择\n下列哪个命令可以删除一个用户和他的主目录\nA rmuser -r\nB deluser -r\nC userdel -r\nD usermgr -r\n三、简答\n默认时普通用户使用 sudo 需不需要验证密码？ 文件权限管理 # 为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。\n在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：\nchown (change owner) ： 修改所属用户与组。 chmod (change mode) ： 修改用户的权限。 下图中通过 chown 来授权用户，通过 chmod 为用户设置可以开门的权限。\n在 Linux 中我们可以使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组，如：\nls -l total 64 dr-xr-xr-x 2 root root 4096 Dec 14 2012 bin dr-xr-xr-x 4 root root 4096 Apr 19 2012 boot 从左至右第 0-9 位上的字符所表示的信息有：\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\n同时，在 Linux 系统中，用户是按组分类的，一个用户属于一个或多个组。\n文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。\n因此， Linux 系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n更改文件属性 # chgrp：更改文件属组\n语法：\nchgrp [-R] 属组名 文件名 chown：更改文件所有者（owner），也可以同时更改文件所属组。\n语法：\nchown [–R] 所有者 文件名 chown [-R] 所有者:属组名 文件名 chmod：更改文件 9 个属性\nLinux 文件属性有两种设置方法，一种是数字，一种是符号。\nLinux 文件的基本权限就有九个，分别是 owner/group/others （拥有者/组/其他）三种身份各有自己的 read/write/execute 权限。\n其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n类型 缩写 代表数字 r read 4 w write 2 x execute 1 每种身份 (owner/group/others) 各自的三个权限 (r/w/x) 分数是需要累加的，例如当权限为： -rwxrwx--- 分数则是：\nowner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= --- = 0+0+0 = 0 所以该文件的权限数字就是 770。\n变更权限的指令 chmod 的语法如下：\nchmod [-R] xyz 文件或目录 或者可以使用字符来代表添加或删除权限\n语法如下：\nchmod [u/g/o] [+/-] 文件 例如：\nchmod u+x text chmod g+w text chmod o-r text 习题 # 一、简答\n某文件的权限用数字法表示为 755，那么对应的字符法表示是什么？ 实训 # 按顺序执行\n在当前用户主目录下建立以姓名命名的目录，并进入\n在当前目录下建立文件 exam.c，将文件 exam.c 拷贝到 /tmp 这个目录下\n进入 /tmp 后回到用户主目录\n查看当前目录（隐藏文件也显示）后进入姓名文件夹\n在当前目录中新建文件 text.txt 并设置文件的属性为文件属主 (u) 增加执行权限与文件属主同组用户 (g) 增加写权限其他用户 (o) 删除读权限\n创建用户 test1 和 test2 并将 /home/test1 目录中的所有文件拷贝到目录 /home/test2 中\n在姓名目录中建立文件 file1.txt 并更名为 file2.doc\n用一行命令修改姓名目录下所有文件属性对拥有者、群组可读可写可执行？\n新建一个组 group1，将 root 用户添加到该组，并查看是否添加成功？\n姓名目录中建立文件 ff.txt 并用数字的形式把文件的权限改为 rw-rw-rw-？\n在姓名目录中新建 1.txt 2.txt 3.txt 1.c 2.c 3.c 1.doc 2.doc 3.doc\n将姓名目录中扩展名为 c、txt 和 doc 的文件全部复制到 /home 目录中\n","date":"7 September 2024","externalUrl":null,"permalink":"/cs_04/","section":"文章列表","summary":"本文介绍 Linux 简介、优点、版本、文件系统、SSH 连接、习题。","title":"Day 4 Linux 速成","type":"blog"},{"content":"","date":"5 September 2024","externalUrl":null,"permalink":"/slug/cs_03_test/","section":"Slug","summary":"","title":"Cs_03_test","type":"slug"},{"content":" 1. 计算机主机是由 CPU 与下列哪种设备共同构成（）\nA 控制器\nB 运算器\nC 输入、输出设备\nD 内存储器\n答案：D A. 控制器 - 控制器是 CPU 的一部分，不是与 CPU 共同构成主机的独立设备。\nB. 运算器 - 运算器也是 CPU 的一部分。\nC. 输入、输出设备 - 这些是外围设备，不是主机的组成部分。\nD. 内存储器 - 正确。CPU 与内存储器共同构成计算机的主机。\n2. 完整的计算机系统由（）组成\nA 运算器、控制器、存储器、输入设备和输出设备\nB 主机和外部设备\nC 硬件系统和软件系统\nD 主机箱、显示器、键盘、鼠标、打印机\n答案：C A. 运算器、控制器、存储器、输入设备和输出设备 - 这些是计算机的硬件组成部分。\nB. 主机和外部设备 - 这是硬件系统的描述，但不完整。\nC. 硬件系统和软件系统 - 正确。完整的计算机系统包括硬件和软件。\nD. 主机箱、显示器、键盘、鼠标、打印机 - 这些都是硬件设备，不包括软件。\n3. 在外部设备中，绘图仪属于（）\nA 辅（外）存储器\nB 主（内）存储器\nC 输入设备\nD 输出设备\n答案：D A. 辅（外）存储器 - 绘图仪不是存储设备。\nB. 主（内）存储器 - 绘图仪不是存储设备。\nC. 输入设备 - 绘图仪可以是输入设备，但它主要是输出设备。\nD. 输出设备 - 正确。绘图仪用于输出图形，是输出设备。\n4. 既是输入设备又是输出设备的是（）\nA 磁盘驱动器\nB 显示器\nC 键盘\nD 鼠标\n答案：A A. 磁盘驱动器 - 可以读取数据（输入）和写入数据（输出）。\nB. 显示器 - 主要是输出设备。\nC. 键盘 - 是输入设备。\nD. 鼠标 - 也是输入设备。\n5. 不同类型的存储器组成多层次的存储器体系，按照速度从快到慢排列的是（）\nA 快存/辅存/主存\nB 外存/主存/辅存\nC 快存/主存/辅存\nD 主存/辅存/外存\n答案：C “快存” 指的是高速缓存存储器（Cache Memory），通常简称为缓存。高速缓存是一种位于 CPU 和主内存（RAM）之间的小容量但高速度的半导体存储器，其目的是减少 CPU 访问主内存所需的平均时间。\nA. 快存/辅存/主存 - 顺序错误。\nB. 外存/主存/辅存 - 顺序错误。\nC. 快存/主存/辅存 - 正确。速度从快到慢：快存（如 CPU 缓存）、主存（RAM）、辅存（如硬盘）。\nD. 主存/辅存/外存 - 顺序错误。\n6. 任何程序都必须加载到（）才能被 CPU 执行\nA 磁盘\nB 硬盘\nC 内存\nD 外存\n答案：C A. 磁盘 - 磁盘上的数据需要加载到内存中才能被 CPU 执行。\nB. 硬盘 - 同 A。\nC. 内存 - 正确。CPU 直接从内存中读取指令和数据。\nD. 外存 - 外存数据需要先加载到内存。\n7. 处理器一次能处理的数据量叫作字长，已知 64 位的 CPU 一次能处理 64 个信息，相当于多少字节（）\nA 1 个\nB 2 个\nC 8 个\nD 64 个\n答案：C 64 位的 CPU，意味着它一次能处理 64 位（bit）的数据。\nA. 1 个 - 错误。\nB. 2 个 - 错误。\nC. 8 个 - 正确。64 位等于 8 字节。\nD. 64 个 - 错误。\n8. 在计算机中用 byte 表示（）\nA 字\nB 字长\nC 二进制位\nD 字节\n答案：D A. 字 - 不正确。\nB. 字长 - 不正确。\nC. 二进制位 - 不正确。\nD. 字节 - 正确。Byte 是字节的英文，是计算机存储的基本单位。\n9. 用一个字节最多能编出（）不同的码\nA 8 个\nB 16 个\nC 128 个\nD 256 个\n答案：D 一个字节（Byte）由 8 位（bit）组成。每一位可以是 0 或 1，代表两种状态。\n因此，一个字节可以表示的组合数是每一位状态的乘积。对于每一位，我们有 2 种选择（0 或 1），所以一个字节可以表示的组合数为： \\(2^8\\)\n10. 下列描述中，正确的是（）\nA 1 KB = 1024 X 1024 Bytes\nB 1 MB = 1024 X 1024 Bytes\nC 1 KB = 1024 MB\nD 1 MB = 1024 Bytes\n答案：B A. 1 KB = 1024 X 1024 Bytes - 错误，1 KB = 1024 Bytes\nB. 1 MB = 1024 X 1024 Bytes - 错误，1 MB = 1024 KB。\nC. 1 KB = 1024 MB - 错误。\nD. 1 MB = 1024 Bytes - 错误。\n\\(1 \\text{ TB} = 1024 \\text{ GB} = 1024^2 \\text{ MB} = 1024^3 \\text{ KB} = 1024^4 \\text{ B} = 1024^5 \\text{ bit}\\)\n11. 数据和程序存储在磁盘上的形式是（）\nA 集合\nB 文件\nC 目录\nD 记录\n答案：B A. 集合 - 错误。集合不是存储数据和程序的形式。\nB. 文件 - 正确。数据和程序在磁盘上以文件的形式存储。\nC. 目录 - 错误。目录用于组织文件，但不是存储形式。\nD. 记录 - 错误。记录是数据库中的概念。\n12. 下列存储器中，断电后信息将会丢失的是（）\nA ROM\nB RAM\nC CD－ROM\nD 磁盘存储器\n答案：B A. ROM - 错误。Read-Only Memory（只读存储器）在断电后信息不会丢失。\nB. RAM - 正确。Random Access Memory（随机存取存储器）在断电后会丢失信息。\nC. CD-ROM - 错误。Compact Disc Read-Only Memory 是只读的，信息不会丢失。\nD. 磁盘存储器 - 错误。这取决于磁盘的类型，如 SSD 或 HDD，但通常不是 RAM。\n13. RAM 代表（）\nA 只读存储器\nB 高速缓存器\nC 随机存储器\nD 软盘存储器\n答案：C A. 只读存储器 - 错误。这是 ROM。\nB. 高速缓存器 - 错误。这是 Cache。\nC. 随机存储器 - 正确。RAM 是随机存取存储器。\nD. 软盘存储器 - 错误。这是对软盘的描述，不是 RAM。\n14. 微型计算机的内存容量主要指（）的容量\nA RAM\nB ROM\nC CMOS\nD Cache\n答案：A A. RAM - 正确。内存容量通常指的是 RAM 的大小。\nB. ROM - 错误。ROM 通常包含固件或系统软件，不计入内存容量。\nC. CMOS - 错误。CMOS 是存储小量系统设置的地方。\nD. Cache - 错误。Cache 是高速缓存，虽然重要但不是内存容量的主要部分。\n15. 我国第一台电子计算机于（）试制成功\nA 1953\nB 1958\nC 1964\nD 1978\n答案：B A. 1953 - 错误。\nB. 1958 - 正确。中国第一台电子计算机在 1958 年试制成功。\nC. 1964 - 错误。\nD. 1978 - 错误。\n16. 计算机所具有的存储程序和程序原理是（）提出来的\nA 图灵\nB 布尔\nC 约翰·冯诺伊曼\nD 爱因斯坦\n答案：C A. 图灵 - 错误。图灵提出了图灵机的概念，对计算理论有重大贡献。\nB. 布尔 - 错误。布尔是逻辑代数的创始人。\nC. 约翰·冯诺伊曼 - 正确。冯诺伊曼提出了存储程序和程序控制原理。\nD. 爱因斯坦 - 错误。爱因斯坦是物理学家，与计算机原理无关。\n17. 世界上第一台电子数字计算机采用的主要逻辑部件是（）\nA 电子管\nB 晶体管\nC 继电器\nD 光电管\n答案：A A. 电子管 - 正确。世界上第一台电子数字计算机 ENIAC 使用电子管。\nB. 晶体管 - 错误。晶体管在后来的计算机中使用。\nC. 继电器 - 错误。继电器用于早期机械式计算机。\nD. 光电管 - 错误。光电管用于检测光，不是主要逻辑部件。\n18. 微型计算机系统的中央处理器通常是指（）\nA 内存储器和控制器\nB 内存储器和运算器\nC 运算器和控制器\nD 内存储器、控制器和运算器\n答案：C A. 内存储器和控制器 - 错误。内存储器通常指的是 RAM，是计算机的一个独立组件，不包含在 CPU 中。\nB. 内存储器和运算器 - 错误。虽然 CPU 包含运算器，但内存储器（如 RAM）是单独的组件。\nC. 运算器和控制器 - 正确。CPU 的核心功能包括运算器和控制器，这两个部件共同实现了 CPU 的主要任务。\nD. 内存储器、控制器和运算器 - 错误。虽然 CPU 包含控制器和运算器，但内存储器（如 RAM）是单独的组件。\n19. 存储器可分为哪两类（）\nA 硬盘和软盘\nB ROM 和 EPROM\nC RAM 和 ROM\nD 内存储器和外存储器\n答案：D A. 硬盘和软盘 - 错误。这是存储介质的类型，不是存储器的分类。\nB. ROM 和 EPROM - 错误。这是存储器的类型，但不是主要分类。\nC. RAM 和 ROM - 错误。RAM 是随机存取存储器，ROM 是只读存储器。\nD. 内存储器和外存储器 - 正确。这是主要的存储器分类\n20. 下列属于软件的是（）\nA 主机\nB 键盘\nC 显示器\nD 操作系统\n答案：D A. 主机 - 错误。主机是硬件。\nB. 键盘 - 错误。键盘是输入设备。\nC. 显示器 - 错误。显示器是输出设备。\nD. 操作系统 - 正确。操作系统是软件，用于管理计算机硬件和软件资源\n21. 操作系统是重要的系统软件，下列不属于操作系统的是（）\nA Unix\nB Linux\nC PASCAL\nD Windows XP\n答案：C A. Unix - 错误。Unix 是一种操作系统。\nB. Linux - 错误。Linux 也是一种操作系统。\nC. PASCAL - 正确。PASCAL 是一种编程语言，不是操作系统。\nD. Windows XP - 错误。Windows XP 是一种操作系统。\n22. 操作系统是在第（）代计算机开始应用的\nA 第一代\nB 第二代\nC 第三代\nD 第四代\n答案：C 操作系统的早期形式，如批处理系统和监控程序，是在第二代计算机期间开始出现的。但是，更现代意义上的操作系统，具备更强的内存管理、多任务处理、设备驱动程序、用户界面等功能，是在第三代计算机期间得到显著发展和广泛应用的。\nA. 第一代 - 早期的计算机，如 ENIAC，主要用于特定任务，操作系统的概念尚未成熟。\nB. 第二代 - 引入了晶体管，计算机开始有了批处理系统，这是操作系统的早期形式。\nC. 第三代 - 集成电路的引入，操作系统变得更复杂，如 Unix。\nD. 第四代 - 微处理器和个人电脑的普及，操作系统发展出图形用户界面。\n23. 下面四个不同进制的数，最小的一个数是（）\nA \\((11011001)_2\\)\nB \\((37)_8\\)\nC \\((75)_{10}\\)\nD \\((A7)_{16}\\)\n答案：B A. \\((11011001)_2\\) - 转换为十进制是 217。\nB. \\((37)_8\\) - 转换为十进制是 31。\nC. \\((75)_{10}\\) - 已经是十进制，值为 75。\nD. \\((A7)_{16}\\) - 转换为十进制是 167。\n24. 下列十进制整数中，能用八位二进制表示的是（）\nA 296\nB 333\nC 256\nD 199\n答案：C 最大 8 位二进制 \\((11111111)_2=(255)_{10}\\)\nA. 296 - 超过 8 位二进制能表示的最大值 255。\nB. 333 - 同样超过 255。\nC. 256 - 同样超过 255。\nD. 199 - 199 小于 255，因此可以用八位二进制表示。\n25. 小明用十六进制、八进制和十进制写下如下等式：52-19=33。试问 52、19、33 分别是（）\nA 八、十、十六\nB 十、十六、八\nC 八、十六、十\nD 十、八、十六\n答案：B 根据等式 52 - 19 = 33，我们可以推断：\nA. 八、十、十六 - 不正确，\\(42 - 19 = 23 \\ne 51\\)\nB. 十、十六、八 - 正确，52−25=27\nC. 八、十六、十 - 不正确，\\(42 - 25 = 17 \\ne 33\\)\nD. 十、八、十六 - 不正确，\\(52 - 17 = 35 \\ne 51\\)\n26. 十进制算术表达式：\\(3*512+7*64+4*8+5\\) 的运算结果，用二进制表示为（）\nA 10111100101\nB 11111100101\nC 100101\nD 2021\n答案：B 计算表达式：\\(3*512+7*64+4*8+5=2021\\)\n2021 的二进制表达式是 11111100101\n27. 已知在某进制计数下，\\(2*4=11\\)，根据这个运算法则，\\(5*16\\) 的结果是（）\nA 80\nB 122\nC 143\nD 212\n答案：B 在只有个位的情况下，不同进制的值都是相同的\n根据给定的运算法则，\\(2×4=8=(11)_7\\)，所以该进制是 7 进制。\n因此，\\((5)_7×(16)_7=5x13=65=(122)_7\\)\n28. 二进制加法：11001001+00100111 结果是（）\nA 11101111\nB 11110000\nC 00000001\nD 10100010\n答案：B 进行二进制加法：11001001+00100111=11110000\n29. 二进制数 1110111.11 转换成十进制数是（）\nA 119.125\nB 119.3\nC 119.375\nD 119.75\n答案：D 二进制数 1110111.11 转换为十进制是 119.75。\n30. 有一个数值 152，它与十六进制 6A 相等，则 152 是（）\nA 二进制\nB 四进制\nC 八进制\nD 十进制\n答案：C 十六进制 6A 等于十进制 106。\n因此，152 是八进制，与 6A 相等。\n31. 信息高速公路传送的是（）\nA 二进制数据\nB 多媒体信息\nC 程序数据\nD 各种数字信息\n答案：A A. 二进制数据 - 正确。信息高速公路主要传输二进制形式的数据。\nB. 多媒体信息 - 错误。虽然多媒体信息也是二进制数据，但这个选项不够具体。\nC. 程序数据 - 错误。程序数据是二进制数据的一种，但这个选项同样不够全面。\nD. 各种数字信息 - 错误。这个描述过于宽泛，不如选项 A 准确。\n32. 你认为最能准确反映计算机主要功能的是（）\nA 计算机可以代替人的脑力劳动\nB 计算机可以存储大量信息\nC 计算机是一种信息处理机\nD 计算机可以实现高速度的运算\n答案：C A. 计算机可以代替人的脑力劳动 - 错误。这是计算机的功能之一，但不是最能准确反映其主要功能的描述。\nB. 计算机可以存储大量信息 - 错误。这也是计算机的功能之一，但同样不是最准确的描述。\nC. 计算机是一种信息处理机 - 正确。这个描述最全面地概括了计算机的主要功能。\nD. 计算机可以实现高速度的运算 - 错误。虽然这是计算机的能力之一，但不如选项 C 全面。\n33. 不同的计算机，其指令系统也不相同，主要取决（）\nA 用的 CPU\nB 用的操作系统\nC 用的程序设计语言\nD 系统的总体结构\n答案：A A. 用的 CPU - 正确。不同的 CPU 有不同的指令集，因此决定了计算机的指令系统。\nB. 用的操作系统 - 错误。操作系统是在硬件基础上的软件，它并不决定指令系统。\nC. 用的程序设计语言 - 错误。程序设计语言是用于编写程序的工具，不决定指令系统。\nD. 系统的总体结构 - 错误。虽然系统的总体结构对指令系统有一定影响，但最直接的因素是 CPU。\n34. 在微机中，VGA 的含义是（）\nA 微机型号\nB 键盘型号\nC 显示标准\nD 显示器型号\n答案：C A. 微机型号 - 错误。VGA 不是微机型号。\nB. 键盘型号 - 错误。VGA 与键盘型号无关。\nC. 显示标准 - 正确。VGA 是一种显示标准，定义了显示的分辨率和颜色深度等参数。\nD. 显示器型号 - 错误。VGA 不是特定的显示器型号。\n35. 下列因素中，对计算机工作影响最小的是（）\nA 尘土\nB 噪声\nC 温度\nD 湿度\n答案：B A. 尘土 - 错误。尘土可能会影响计算机硬件的性能和寿命。\nB. 噪声 - 正确。噪声对计算机工作的影响相对较小，除非噪声水平极高。\nC. 温度 - 错误。过高或过低的温度都会影响计算机硬件的性能和寿命。\nD. 湿度 - 错误。湿度过高可能会导致硬件腐蚀或短路。\n36. 计算机之所以被称之为电脑是因为（）\nA 计算机是人类大脑的衍生\nB 计算机具有逻辑判断功能\nC 计算机有强大记忆能力\nC 计算机有瞬息万变的控制功能\n答案：C A. 计算机是人类大脑的衍生 - 错误。虽然计算机在某种程度上模仿了人脑的功能，但这个描述并不准确。\nB. 计算机具有逻辑判断功能 - 错误。计算机并不具备逻辑判断功能，只不过是按照人类编辑的运算方法运行特定的程序而已，计算机本身并不能思考\nC. 计算机有强大记忆能力 - 正确。\nD. 计算机有瞬息万变的控制功能 - 错误。这个描述过于模糊。\n37. 文件型病毒传染的主要对象是（）\nA 文本文件\nB 系统文件\nC 可执行文件\nD .exe 和 .com 文件\n答案：C A. 文本文件 - 错误。文本文件不是病毒传染的主要对象。\nB. 系统文件 - 错误。虽然病毒可能会感染系统文件，但不是主要对象。\nC. 可执行文件 - 正确。可执行文件是病毒传染的主要对象，因为它们可以被执行。\nD. .exe 和.com 文件 - 错误。虽然这些是可执行文件的类型，但选项 C 的描述更全面。\n38. 直接通过总线与 CPU 连接的部件是（）\nA 显示器\nB 内存储器\nC 磁盘\nD 键盘\n答案：B A. 显示器 - 错误。显示器通过视频接口与计算机连接，不是直接通过总线与 CPU 连接。\nB. 内存储器 - 正确。内存储器（如 RAM）直接通过总线与 CPU 连接，以便快速数据交换。\nC. 磁盘 - 错误。磁盘通过磁盘控制器与计算机连接，不是直接与 CPU 连接。\nD. 键盘 - 错误。键盘通过输入接口与计算机连接，不是直接与 CPU 连接。\n39. 计算机病毒指得是（）\nA 能传染给用户的磁盘病毒\nB 已感染病毒的磁盘\nC 具有破坏性的程序\nD 已感染病毒的程序\n答案：C A. 能传染给用户的磁盘病毒 - 错误。这个描述不准确，病毒不仅仅是传染给用户的磁盘。\nB. 已感染病毒的磁盘 - 错误。这个描述指的是被感染的对象，而不是病毒本身。\nC. 具有破坏性的程序 - 正确。计算机病毒是具有破坏性的程序。\nD. 已感染病毒的程序 - 错误。这个描述指的是被感染的对象，而不是病毒本身。\n40. 最早的计算机的用途是（）\nA 科学计算\nB 自动控制\nC 辅助设计\nD 系统仿真\n答案：A A. 科学计算 - 正确。最早的计算机主要用于科学计算。\nB. 自动控制 - 错误。虽然计算机后来被用于自动控制，但不是最早的用途。\nC. 辅助设计 - 错误。辅助设计是计算机的后期应用之一。\nD. 系统仿真 - 错误。系统仿真也是计算机的后期应用之一。\n41. 国产银河型数字式电子计算机数属于下列哪种类型的计算机（）\nA 微型\nB 小型\nC 中型\nD 巨型\n答案：D A. 微型 - 错误。银河型数字式电子计算机不是微型计算机。\nB. 小型 - 错误。银河型计算机属于更大型的计算机。\nC. 中型 - 错误。银河型计算机超出了中型计算机的规模。\nD. 巨型 - 正确。银河型数字式电子计算机是中国研制的高性能大型计算机。\n42. 世界上第一台电子数字计算机采用的主要逻辑部件是（）\nA 电子管\nB 晶体管\nC 继电器\nD 光电管\n答案：A A. 电子管 - 正确。世界上第一台电子数字计算机 ENIAC 使用的主要逻辑部件是电子管。\nB. 晶体管 - 错误。晶体管在后来的计算机中使用。\nC. 继电器 - 错误。继电器用于早期机械式计算机。\nD. 光电管 - 错误。光电管用于检测光，不是主要逻辑部件。\n43. 左手无名指应放在（）键上\nA S\nB D\nC J\nD K\n答案：A A. S - 正确。在标准打字指法中，左手无名指应放在 S 键上。\nB. D - 错误。这不是标准打字指法中的键位。\nC. J - 错误。这不是标准打字指法中的键位。\nD. K - 错误。这不是标准打字指法中的键位。\n44. 硬盘工作时应特别注意（）\nA 噪声\nB 震动\nC 潮湿\nD 日光\n答案：B A. 噪声 - 错误。噪声对硬盘的影响相对较小。\nB. 震动 - 正确。硬盘在工作时非常敏感，震动可能导致数据损坏或物理损伤。\nC. 潮湿 - 错误。虽然潮湿对所有电子设备都有害，但对硬盘工作时的影响不如震动直接。\nD. 日光 - 错误。日光对硬盘工作的影响相对较小。\n45. Windows 目录结构采用的是（）\nA 树形结构\nB 线性结构\nC 层次结构\nD 网状结构\n答案：A A. 树形结构 - 正确。Windows 目录结构采用的是树形结构，便于管理和访问。\nB. 线性结构 - 错误。这不是 Windows 目录结构的特点。\nC. 层次结构 - 错误。层次结构不适用于描述 Windows 目录结构。\nD. 网状结构 - 错误。网状结构也不适用于描述 Windows 目录结构。\n46. 将回收站中的文件还原时，被还原的文件将回到（）\nA 桌面上\nB “我的文档” 中\nC 内存中\nD 被删除的位置\n答案：D A. 桌面上 - 错误。被还原的文件不会回到桌面上。\nB. “我的文档”中 - 错误。被还原的文件不会自动移动到“我的文档”中。\nC. 内存中 - 错误。内存是计算机的临时存储区域，文件还原后仍然保存在硬盘上。\nD. 被删除的位置 - 正确。将文件从回收站还原会将其恢复到原先被删除时的位置。\n47. 在计算机上插 U 盘的接口通常是（）标准接口\nA UPS\nB USP\nC UBS\nD USB\n答案：D A. UPS - 错误。UPS 指的是不间断电源。\nB. USP - 错误。这不是一个标准的接口名称。\nC. UBS - 错误。这同样不是一个标准的接口名称。\nD. USB - 正确。USB 是通用串行总线，是计算机上用于连接外围设备的标准接口。\n48. 办公自动化是计算机的一项应用，按计算机应用的分类，它属于（）\nA 科学计算\nB 实时控制\nC 数据处理\nD 辅助设计\n答案：C A. 科学计算 - 错误。科学计算是计算机应用的一个领域，但不是办公自动化。\nB. 实时控制 - 错误。实时控制是另一个计算机应用领域。\nC. 数据处理 - 正确。办公自动化主要涉及数据处理，如文字处理、电子表格等。\nD. 辅助设计 - 错误。辅助设计是计算机应用的另一个领域，与办公自动化不同。\n49. 计算机辅助设计的英文缩写是（）\nA CAD\nB CAE\nC CAI\nD CAM\n答案：A A. CAD - 正确。CAD 是计算机辅助设计的英文缩写。\nB. CAE - 错误。CAE 是计算机辅助工程的缩写。\nC. CAI - 错误。CAI 是计算机辅助教学的缩写。\nD. CAM - 错误。CAM 是计算机辅助制造的缩写。\n50. 下面不属于计算机病毒特性的是（）\nA 潜伏性\nB 激发性\nC 传播性\nD 免疫性\n答案：D A. 潜伏性 - 错误。潜伏性是计算机病毒的一个特性。\nB. 激发性 - 错误。激发性也是计算机病毒的一个特性。\nC. 传播性 - 错误。传播性同样是计算机病毒的一个特性。\nD. 免疫性 - 正确。计算机病毒没有免疫性，免疫性是反病毒软件的特性。\n51. 磁盘处于保护状态，那么磁盘中的数据（）\nA 不能读出，不能删改，不能写入\nB 能读出，不能删改，不能写入\nC 能读出，能删改，不能写入\nD 能读出，不能删改，能写入\n答案：B A. 不能读出，不能删改，不能写入 - 错误。这描述的是完全锁定的状态。\nB. 能读出，不能删改，不能写入 - 正确。这是磁盘保护状态下的典型特征，可以读取数据，但不能修改或写入。\nC. 能读出，能删改，不能写入 - 错误。这不符合保护状态的定义。\nD. 能读出，不能删改，能写入 - 错误。如果能够写入，那么磁盘就不处于保护状态。\n52. 启动计算机引导 Windows 是将操作系统（）\nA 从磁盘调入中央处理器\nB 从内存储器调入高速缓存存储器\nC 从软盘调入硬盘\nD 从系统盘调入内存储器\n答案：D A. 从磁盘调入中央处理器 - 错误。操作系统是从磁盘调入内存，然后由 CPU 从内存中读取指令执行。\nB. 从内存储器调入高速缓存存储器 - 错误。这是计算机内部数据的缓存机制，不是操作系统启动的过程。\nC. 从软盘调入硬盘 - 错误。软盘是外部存储介质，操作系统启动通常是从硬盘加载到内存。\nD. 从系统盘调入内存储器 - 正确。操作系统在启动时是从系统盘（通常是硬盘）加载到内存中。\n53. 各种应用程序都必须在（）的支持下运行\nA 编程程序\nB 计算机语言程序\nC 字处理程序\nD 操作系统\n答案：D A. 编程程序 - 错误。编程程序是用于编写代码的工具，不是运行应用程序的环境。\nB. 计算机语言程序 - 错误。计算机语言程序是指用特定编程语言编写的程序，不是运行环境。\nC. 字处理程序 - 错误。字处理程序是一类应用程序，不是所有应用程序运行的基础。\nD. 操作系统 - 正确。操作系统提供了运行应用程序所需的基本功能和环境。\n54. 新建文档时，Word 默认的字体和字号分别是（）\nA 黑体、3 号\nB 楷体、4 号\nC 宋体、5 号\nD 仿宋、6 号\n答案：C A. 黑体、3 号 - 错误。这不是 Word 默认的字体和字号。\nB. 楷体、4 号 - 错误。这不是 Word 默认的字体和字号。\nC. 宋体、5 号 - 正确。在许多版本的 Word 中，新建文档默认使用宋体，字号为 5 号。\nD. 仿宋、6 号 - 错误。这不是 Word 默认的字体和字号。\n55. 第一次保存 Word 文档时，系统将打开（）对话框\nA 保存\nB 另存为\nC 新建\nD 关闭\n答案：B A. 保存 - 错误。\u0026ldquo;保存\u0026quot;命令用于保存已有文档，而不是新建文档。\nB. 另存为 - 正确。第一次保存新建的 Word 文档时，系统通常会打开\u0026quot;另存为\u0026quot;对话框，让用户选择保存位置和文件名。\nC. 新建 - 错误。\u0026ldquo;新建\u0026quot;用于创建新文档，而不是保存文档。\nD. 关闭 - 错误。\u0026ldquo;关闭\u0026quot;用于关闭文档，不涉及保存操作。\n56. 在 Word 表格中，位于第三行第四列的单元格名称是（）\nA 3∶4\nB 4∶3\nC D3\nD C4\n答案：C A. 3∶4 - 错误。这不是 Word 表格中单元格的表示方式。\nB. 4∶3 - 错误。这不是 Word 表格中单元格的表示方式。\nC. D3 - 正确。这表示第三行第四列的单元格。\nD. C4 - 错误。这表示第四行第三列的单元格，但问题是第三行第四列。\n57. 新建的 Excel 工作簿中默认有（）张工作表\nA 2\nB 3\nC 4\nD 5\n答案：B A. 2 - 错误。这不是 Excel 工作簿默认的工作表数量。\nB. 3 - 正确。新建的 Excel 工作簿默认包含 3 张工作表。\nC. 4 - 错误。这不是 Excel 工作簿默认的工作表数量。\nD. 5 - 错误。这不是 Excel 工作簿默认的工作表数量。\n58. 用 PowerPoint 制作的演示文稿默认的扩展名是（）\nA .pwp\nB .ppt\nC .ppn\nD .pop\n答案：B A. .pwp - 错误。这不是 PowerPoint 演示文稿的默认扩展名。\nB. .ppt - 正确。PowerPoint 演示文稿的默认扩展名是.ppt。\nC. .ppn - 错误。这不是 PowerPoint 演示文稿的扩展名。\nD. .pop - 错误。这不是 PowerPoint 演示文稿的扩展名。\n59. 操作系统的功能是（）\nA 处理机管理、存储器管理、设备管理、文件管理\nB 运算器管理、控制器管理、打印机管理、磁盘管理\nC 硬盘管理、软盘管理、存储器管理、文件管理\nD 程序管理、文件管理、编译管理、设备管理\n答案：A A. 处理机管理、存储器管理、设备管理、文件管理 - 正确。这些都是操作系统的基本功能。\nB. 运算器管理、控制器管理、打印机管理、磁盘管理 - 错误。这不是操作系统功能的准确描述。\nC. 硬盘管理、软盘管理、存储器管理、文件管理 - 错误。这个描述不够全面，且软盘管理已过时。\nD. 程序管理、文件管理、编译管理、设备管理 - 错误。编译管理不是操作系统的核心功能。\n60. 计算机网络最突出的优点是（）\nA 传送信息速度高\nB 共享资源\nC 内存容量大\nD 交互性好\n答案：B A. 传送信息速度高 - 错误。虽然这是优点之一，但不是最突出的。\nB. 共享资源 - 正确。计算机网络最突出的优点是能够实现资源的共享。\nC. 内存容量大 - 错误。内存容量与网络结构不直接相关。\nD. 交互性好 - 错误。虽然交互性是网络的一个优点，但不如资源共享突出。\n61. 在描述信息传输中 bps 表示的是（）\nA 每秒传输的字节数\nB 每秒传输的指令数\nC 每秒传输的字数\nD 每秒传输的位数\n答案：D A. 每秒传输的字节数 - 错误。bps 代表的是位，而非字节。\nB. 每秒传输的指令数 - 错误。这个单位不是用来衡量指令数的。\nC. 每秒传输的字数 - 错误。通常不使用这个单位来衡量数据传输速率。\nD. 每秒传输的位数 - 正确。bps 是 bits per second 的缩写，表示每秒传输的位数。\n62. 汉字的拼音输入码属于汉字的（）\nA 外码\nB 内码\nC ASCII 码\nD 标准码\n答案：A A. 外码 - 正确。拼音输入码是汉字的外码，用于将拼音转换为汉字。\nB. 内码 - 错误。内码是计算机内部用于表示字符的编码方式。\nC. ASCII 码 - 错误。ASCII 码是用于表示英文字符和一些特殊符号的编码。\nD. 标准码 - 错误。这个术语不专门指代任何特定的编码系统。\n63. 在计算机系统内部，汉字的表示方法是采用（）\nA ASCII 码\nB 机内码\nC 国标码\nD 区位码\n答案：B A. ASCII 码 - 错误。ASCII 码用于表示英文字符，不适用于汉字。\nB. 机内码 - 正确。在计算机系统内部，汉字通常使用特定的机内码表示。\nC. 国标码 - 错误。国标码（GB 编码）是用于汉字编码的一种标准，但不是内部表示方法。\nD. 区位码 - 错误。区位码是汉字编码的一种方式，但不是计算机内部的表示方法。\n64. 用以太网形式构成的局域网，其拓扑结构为（）\nA 环型\nB 总线型\nC 星型\nD 树型\n答案：B A. 环型 - 错误。环型拓扑不是以太网的标准拓扑结构。\nB. 总线型 - 正确。以太网通常采用总线型拓扑结构，特别是在早期的以太网实现中。\nC. 星型 - 错误。星型拓扑是现代局域网中常见的结构，但不是以太网特有的。\nD. 树型 - 错误。树型拓扑是网络结构的一种，但不特指以太网。\n65. 下列打印机中，打印效果最佳的一种是（）\nA 点阵打印机\nB 激光打印机\nC 热敏打印机\nD 喷墨打印机\n答案：B A. 点阵打印机 - 错误。点阵打印机的打印效果相对较低。\nB. 激光打印机 - 正确。激光打印机提供了高质量的打印效果，特别是文本。\nC. 热敏打印机 - 错误。热敏打印机通常用于票据打印，打印效果有限。\nD. 喷墨打印机 - 错误。虽然喷墨打印机在彩色打印和照片打印方面表现出色，但在文本打印方面，激光打印机通常更优。\n66. 已知：“B” 的 ASCII 码值是 66，则码值为 1000100 的字符为（）\nA “C”\nB “D”\nC “E”\nD “F”\n答案：B 1000100 换算为 16 进制是 44，换算为 10 进制是 68，比 66 大 2，表示字符就是\u0026quot;B\u0026quot;后面的第 2 个，也就是\u0026quot;D\u0026rdquo;，所以答案是 B.\n67. CPU 中临时存放数据的部件是（）\nA 算术逻辑单元\nB 存储器\nC 寄存器\nD 控制器\n答案：C A. 算术逻辑单元 - 错误。算术逻辑单元是 CPU 中执行算术和逻辑运算的部分。\nB. 存储器 - 错误。存储器是计算机的一个组成部分，但不是 CPU 中临时存放数据的部件。\nC. 寄存器 - 正确。寄存器是 CPU 中的小容量存储部件，用于临时存放数据和指令。\nD. 控制器 - 错误。控制器是 CPU 中负责协调操作的部分。\n68. 激光打印机的打印原理是（）\nA 激光直接打在纸上\nB 利用静电转印\nC 激光控制墨粉的运动方向\nD 激光照射样稿\n答案：B A. 激光直接打在纸上 - 错误。激光打印机不是直接在纸上打印。\nB. 利用静电转印 - 正确。激光打印机使用静电转印技术来打印。\nC. 激光控制墨粉的运动方向 - 错误。这是静电复印机的工作原理。\nD. 激光照射样稿 - 错误。这不是激光打印机的工作方式。\n69. 系统软件和应用软件的相互关系是（）\nA 前者以后者为基础\nB 后者以前者为基础\nC 每一类都不以另一类为基础\nD 每一类都以另一类为基础\n答案：B A. 前者以后者为基础 - 错误。应用软件需要系统软件的支持。\nB. 后者以前者为基础 - 正确。应用软件依赖于系统软件，如操作系统。\nC. 每一类都不以另一类为基础 - 错误。应用软件和系统软件是相互依赖的。\nD. 每一类都以另一类为基础 - 错误。这个说法过于绝对。\n70. 下列关于回收站的叙述中正确的是（）\nA 一般情况下，在硬盘上被删除的文件都存放在回收站中\nB 回收站的内容不可以恢复\nC 清空回收站后仍可用命令方式恢复\nD 回收站的内容不占用硬盘空间\n答案：A A. 一般情况下，在硬盘上被删除的文件都存放在回收站中 - 正确。这是 Windows 操作系统的标准行为。\nB. 回收站的内容不可以恢复 - 错误。回收站的内容通常可以恢复。\nC. 清空回收站后仍可用命令方式恢复 - 错误。一旦清空回收站，文件通常无法恢复。\nD. 回收站的内容不占用硬盘空间 - 错误。回收站的内容仍然占用硬盘空间。\n71. 在 Word 中，一个文档有 200 页，将光标移到 112 页的最快方法是（）\nA 用垂直滚动条快移定位于 112 页\nB 用 PgUp 或 PgDn 键定位于 112 页\nC 用向上或向下箭头定位于 112 页\nD 打开 [编辑] 菜单选择 [定位] 命令输入页号\n答案：D A. 用垂直滚动条快移定位于 112 页 - 错误。滚动条可以快速浏览文档，但不是最快定位特定页码的方法。\nB. 用 PgUp 或 PgDn 键定位于 112 页 - 错误。这些键用于逐页浏览，不适合快速定位到特定页码。\nC. 用向上或向下箭头定位于 112 页 - 错误。这些箭头用于小范围移动，不适合快速定位到特定页码。\nD. 打开 [编辑] 菜单选择 [定位] 命令输入页号 - 正确。使用定位功能可以直接跳转到文档中的特定页码。\n72. 计算机网络成员交换数据必须遵守的规则称作（）\nA 通信\nB 通道\nC 协议\nD 配置\n答案：C A. 通信 - 错误。通信是数据交换的过程，不是规则。\nB. 通道 - 错误。通道指的是数据传输的路径，不是规则。\nC. 协议 - 正确。协议定义了网络成员交换数据必须遵守的规则。\nD. 配置 - 错误。配置指的是网络的设置，不是数据交换的规则。\n73. 在基于个人计算机的局域网中，网络的核心是（）\nA 网卡\nB 服务器\nC 路由器\nD 网络介质\n答案：B A. 网卡 - 错误。网卡是网络连接的硬件，但不是局域网的核心。\nB. 服务器 - 正确。服务器是局域网的核心，提供资源和数据管理。\nC. 路由器 - 错误。路由器用于网络之间的连接，不是局域网的核心。\nD. 网络介质 - 错误。网络介质是数据传输的物理载体，不是核心。\n74. 中国的顶层域名是（）\nA CHINA\nB CH\nC CN\nD CHI\n答案：C A. CHINA - 错误。这不是标准的顶级域名。\nB. CH - 错误。CH 是瑞士的顶级域名。\nC. CN - 正确。CN 是中国的顶级域名。\nD. CHI - 错误。这不是一个有效的顶级域名。\n75. HTTP 是一种（）\nA 域名\nB 网址\nC 程序设计语言\nD 超文本传输协议\n答案：D A. 域名 - 错误。HTTP 不是域名，而是用于域名系统中的协议。\nB. 网址 - 错误。HTTP 不是网址，而是网址中可能包含的协议部分。\nC. 程序设计语言 - 错误。HTTP 不是编程语言。\nD. 超文本传输协议 - 正确。HTTP（Hypertext Transfer Protocol）是用于传输网页数据的协议。\n76. Google 是一个\nA 搜索引擎\nB 压缩/解压软件\nC 聊天室\nD 新闻组\n答案：A A. 搜索引擎 - 正确。Google 是一个广泛使用的搜索引擎。\nB. 压缩/解压软件 - 错误。这不是 Google 的功能。\nC. 聊天室 - 错误。Google 不是一个聊天室。\nD. 新闻组 - 错误。Google 不是新闻组服务。\n77. 撰写一封电子邮件时，下面可以提供邮件主要内容的项目是\nA 收件人地址\nB 标题\nC 附件\nD 数字签名\n答案：B A. 收件人地址 - 错误。收件人地址是邮件发送的目标，不提供邮件内容。\nB. 标题 - 正确。标题通常是邮件的主要内容的简短描述。\nC. 附件 - 错误。附件可以包含相关信息，但不是邮件主要内容的描述。\nD. 数字签名 - 错误。数字签名用于验证邮件的发送者，不提供邮件内容。\n78. “黑色星期五” 在逢 13 日的星期五发作，表明了计算机病毒除了具有潜伏性，还具有（）\nA 针对性\nB 破坏性\nC 传染性\nD 可触发性\n答案：D A. 针对性 - 错误。针对性不是计算机病毒的特性。\nB. 破坏性 - 错误。破坏性是病毒的特性，但不是“黑色星期五”病毒的特点。\nC. 传染性 - 错误。虽然传染性是病毒的特性，但不是本题的正确答案。\nD. 可触发性 - 正确。“黑色星期五”病毒在特定日期触发，显示其可触发性。\n79. 访问清华大学主页 http://www.thinghua.edu.cn 可通过（）\nA 网上邻居\nB Internet Explorer\nC 单击 “查看/转到” 命令\nD Outlook Express\n答案：B A. 网上邻居 - 错误。网上邻居用于访问局域网中的计算机和资源，不用于访问网站。\nB. Internet Explorer - 正确。Internet Explorer 是一个网页浏览器，可以用来访问清华大学的主页。\nC. 单击 “查看/转到” 命令 - 错误。这不是访问网页的标准方法。\nD. Outlook Express - 错误。Outlook Express 是一个电子邮件客户端，不用于浏览网页。\n80. 访问 Web 服务器需要的软件工具是（）\nA 搜索引擎\nB 浏览器\nC 新闻组\nD 过滤器\n答案：B A. 搜索引擎 - 错误。搜索引擎用于查找信息，不是访问 Web 服务器的工具。\nB. 浏览器 - 正确。浏览器是访问 Web 服务器并浏览网页的软件工具。\nC. 新闻组 - 错误。新闻组用于讨论和信息共享，不是访问 Web 服务器的工具。\nD. 过滤器 - 错误。过滤器用于数据筛选，不是访问 Web 服务器的工具。\n81. 下面合法的 Email 地址是（）\nA liru@126.com\nB liru.126.com\nC liru.szu.edu.cn\nD szu.edu.cn@liru\n答案：A A. liru@126.com - 正确。这个地址符合电子邮件地址的标准格式，包含用户名、\u0026rdquo;@\u0026ldquo;符号和域名。\nB. liru.126.com - 错误。这个地址中用户名和域名之间缺少了“@”符号。\nC. liru.szu.edu.cn - 错误。这个地址中用户名和域名之间缺少了“@”符号。\nD. szu.edu.cn@liru - 错误。电子邮件地址中的用户名和域名顺序颠倒了。\n82. 目前使用的网络传输介质中，传输速率最高的是（）\nA 光纤\nB 同轴电缆\nC 双绞线\nD 电话线\n答案：A A. 光纤 - 正确。光纤是目前使用的网络传输介质中传输速率最高的。\nB. 同轴电缆 - 错误。同轴电缆的传输速率低于光纤。\nC. 双绞线 - 错误。虽然双绞线广泛应用于以太网，但其传输速率通常低于光纤。\nD. 电话线 - 错误。电话线通常用于拨号上网，传输速率远低于光纤。\n83. 矢量图与位图相比，不正确的结论是（）\nA 在缩放时矢量图不会失真，而位图会失真\nB 矢量图占用存储空间较大，而位图则较小\nC 矢量图适应表现变化曲线，而位图适应表现自然景物\nD 矢量图侧重于绘制和艺术性，而位图侧重于获取和技巧性\n答案：B A. 在缩放时矢量图不会失真，而位图会失真 - 正确。矢量图由数学公式定义，可以无损缩放；位图由像素阵列组成，缩放时会失真。\nB. 矢量图占用存储空间较大，而位图则较小 - 错误。实际上，矢量图通常占用较少的存储空间，因为它们可以用较少的数据描述复杂的图像。\nC. 矢量图适应表现变化曲线，而位图适应表现自然景物 - 正确。矢量图适合绘制线条和几何图形，位图适合表现具有丰富色彩和细节的自然图像。\nD. 矢量图侧重于绘制和艺术性，而位图侧重于获取和技巧性 - 正确。矢量图常用于图形设计和艺术创作，位图则常用于照片和现实场景的数字化。\n84. 媒体有两种含义：即表示信息的载体和（）\nA 表达信息的实体\nB 存储信息的实体\nC 传输信息的实体\nD 显示信息的实体\n答案：B A. 表达信息的实体 - 错误。媒体作为信息的载体，其主要功能是传递和存储信息，而不是表达信息。表达信息通常是指信息的创造和呈现方式。\nB. 存储信息的实体 - 正确。媒体不仅可以传递信息，还可以作为信息的存储介质，如书籍、硬盘、光盘等。\nC. 传输信息的实体 - 错误。虽然媒体可以用于传输信息，但这个选项与“信息的载体”这一含义重复，因为作为载体本身就包含了传输的功能。\nD. 显示信息的实体 - 错误。显示信息是媒体的一个功能，但不是其主要含义。显示信息更多是指信息的呈现方式，而不是媒体本身的定义。\n85. 下列高级语言中，能用于面向对象程序设计的语言是（）\nA C 语言\nB C++ 语言\nC FORTRAN 语言\nD Pascal 语言\n答案：B A. C 语言 - 错误。C 语言是一种过程式编程语言，不支持面向对象编程。\nB. C++语言 - 正确。C++是一种支持面向对象编程的语言，提供了类和对象等特性。\nC. FORTRAN 语言 - 错误。FORTRAN 是一种早期的编程语言，主要用于数值计算，不支持面向对象编程。\nD. Pascal 语言 - 错误。Pascal 是一种过程式编程语言，虽然有支持面向对象编程的扩展版本，但本身不是面向对象的。\n86. （）领域是计算机应用中最诱人、也是难度大且目前研究最为活跃的领域之一\nA 辅助设计\nB 信息处理\nC 人工智能\nD 过程控制\n答案：C A. 辅助设计 - 错误。辅助设计是计算机应用的一个领域，但不是研究最为活跃的领域之一。\nB. 信息处理 - 错误。信息处理是计算机的基本功能，但不是当前研究最为活跃的领域。\nC. 人工智能 - 正确。人工智能是当前计算机科学研究中最为活跃和最具挑战性的领域之一。\nD. 过程控制 - 错误。过程控制是计算机应用的一个领域，但不是研究最为活跃的领域。\n87. 决定微处理器性能优劣的重要指标是（）\nA 内存的大小\nB 微处理器的尺寸\nC 主频\nD 内存储器\n答案：C A. 内存的大小 - 错误。内存大小影响计算机的性能，但不是决定微处理器性能优劣的唯一指标。\nB. 微处理器的尺寸 - 错误。微处理器的物理尺寸与其性能没有直接关系。\nC. 主频 - 正确。主频是衡量微处理器性能的重要指标，通常主频越高，处理速度越快。\nD. 内存储器 - 错误。内存储器的大小和速度会影响计算机的整体性能，但不是决定微处理器性能的指标。\n88. ASCII 码可以表示的字符个数是（）\nA 256\nB 255\nC 128\nD 127\n答案：A A. 256 - 正确。ASCII 码可以表示 128 个不同的字符，包括大小写英文字母、数字和控制字符。扩展的 ASCII 码可以表示 256 个字符，包括一些国际字符。\nB. 255 - 错误。ASCII 码可以表示的字符个数不是 255。\nC. 128 - 错误。这是标准 ASCII 码可以表示的字符个数，而不是扩展 ASCII 码。\nD. 127 - 错误。ASCII 码可以表示的字符个数不是 127。\n89. 计算机内部用于处理数据和指令的编码是（）\nA 十进制码\nB 二进制码\nC ASCII 码\nD 汉字编码\n答案：B A. 十进制码 - 错误。十进制码不是计算机内部用于处理数据和指令的编码。\nB. 二进制码 - 正确。计算机内部使用二进制码来处理数据和指令。\nC. ASCII 码 - 错误。ASCII 码是一种字符编码，用于文本数据的表示，不是用于处理所有数据和指令的编码。\nD. 汉字编码 - 错误。汉字编码是用于表示汉字的编码系统，不是计算机内部处理数据和指令的通用编码。\n90. 计算机执行某种操作的命令被称为（）\nA 指令\nB 程序\nC 程序设计语言\nD 指令系统\n答案：A A. 指令 - 正确。计算机执行某种操作的命令被称为指令。\nB. 程序 - 错误。程序是由一系列指令组成的，但单个操作的命令是指令。\nC. 程序设计语言 - 错误。程序设计语言是用于编写程序的语言，不是单个操作的命令。\nD. 指令系统 - 错误。指令系统是一组指令的集合，不是单个操作的命令。\n91. 启动 Windows 操作系统后，桌面系统的屏幕上肯定会显示的图标是（）\nA “回收站” 和 “开始” 按钮\nB “计算机”﹑“回收站” 和 “资源管理器”\nC “计算机”﹑“回收站” 和 “Office”\nD “计算机”﹑“开始” 按钮和 “Internet 浏览器”\n答案：A A. “回收站” 和 “开始” 按钮 - 正确。这两个图标通常会在 Windows 操作系统的桌面上显示。\nB. “计算机”、“回收站” 和 “资源管理器” - 错误。资源管理器不是桌面上显示的图标。\nC. “计算机”、“回收站” 和 “Office” - 错误。Office 不是桌面上显示的默认图标。\nD. “计算机”、“开始” 按钮和 “Internet 浏览器” - 错误。Internet 浏览器不是桌面上显示的默认图标。\n92. 下列关于 Windows 的叙述中，错误的是（）\nA 删除应用程序快捷图标时，会连同其所对应的程序文件一同删除\nB 设置文件夹属性时，可以将属性应用于其包含的所有文件和子文件夹\nC 删除目录时，可将此目录下的所有文件及子目录一同删除\nD 双击某类扩展名的文件，操作系统可启动相关的应用程序\n答案：A A. 删除应用程序快捷图标时，会连同其所对应的程序文件一同删除 - 错误。删除快捷图标只会删除图标，不会删除程序文件。\nB. 设置文件夹属性时，可以将属性应用于其包含的所有文件和子文件夹 - 正确。这是 Windows 文件管理的一个功能。\nC. 删除目录时，可将此目录下的所有文件及子目录一同删除 - 正确。在 Windows 中，删除目录会提示是否同时删除其内容。\nD. 双击某类扩展名的文件，操作系统可启动相关的应用程序 - 正确。这是文件关联功能的一部分。\n93. 关于 Windows 窗口的概念，以下叙述正确的是（）\nA 屏幕上只能出现一个窗口，这就是活动窗口\nB 屏幕上可以出现多个窗口，但只有一个是活动窗口\nC 屏幕上可以出现多个窗口，但不止一个活动窗口\nD 当屏幕上出现多个窗口时，就没有了活动窗口\n答案：B A. 屏幕上只能出现一个窗口，这就是活动窗口 - 错误。屏幕上可以同时出现多个窗口。\nB. 屏幕上可以出现多个窗口，但只有一个是活动窗口 - 正确。活动窗口是当前用户可以与之交互的窗口。\nC. 屏幕上可以出现多个窗口，但不止一个活动窗口 - 错误。一次只能有一个活动窗口。\nD. 当屏幕上出现多个窗口时，就没有了活动窗口 - 错误。无论屏幕上有多少窗口，总会有一个是活动窗口。\n94. 资源管理器中的库是（）\nA 一个特殊的文件夹\nB 一个特殊的文件\nC 硬件的集合\nD 用户快速访问一组文件或文件夹的快捷路径\n答案：D A. 一个特殊的文件夹 - 错误。库不仅仅是一个文件夹。\nB. 一个特殊的文件 - 错误。库不是文件。\nC. 硬件的集合 - 错误。库与硬件无关。\nD. 用户快速访问一组文件或文件夹的快捷路径 - 正确。库允许用户将不同位置的文件夹或文件集合在一起，方便访问。\n95. Excel 2010 工作簿文件的默认扩展名为（）\nA docx\nB xlsx\nC pptx\nD jpeg\n答案：B A. docx - 错误。这是 Word 文档的默认扩展名。\nB. xlsx - 正确。这是 Excel 2010 工作簿文件的默认扩展名。\nC. pptx - 错误。这是 PowerPoint 演示文稿的默认扩展名。\nD. jpeg - 错误。这是图片文件的一种格式。\n96. 对电子工作表中所选择的区域不能够进行操作的是（）\nA 调整行高尺寸\nB 调整列宽尺寸\nC 修改条件格式\nD 保存文档\n答案：D A. 调整行高尺寸 - 正确。用户可以调整电子工作表中行的高度。\nB. 调整列宽尺寸 - 正确。用户可以调整电子工作表中列的宽度。\nC. 修改条件格式 - 正确。用户可以对所选择的区域应用或修改条件格式。\nD. 保存文档 - 错误。保存文档不是对所选择区域的操作，而是对整个文档的操作。\n97. 如果要从一张幻灯片 “溶解” 到下一张幻灯片，应使用（）选项卡进行设置\nA 动作设置\nB 切换\nC 幻灯片放映\nD 自定义动画\n答案：B A. 动作设置 - 错误。动作设置用于设置幻灯片中对象的动画。\nB. 切换 - 正确。在 PowerPoint 中，切换选项卡用于设置幻灯片之间的过渡效果，如“溶解”。\nC. 幻灯片放映 - 错误。这个选项卡用于控制幻灯片的放映设置。\nD. 自定义动画 - 错误。自定义动画用于设置幻灯片中单个对象的动画效果。\n98. 按照网络信号的传输延迟，从大到小排序正确的是（）\nA 局域网、广域网、城域网\nB 局域网、城域网、广域网\nC 广域网、城域网、局域网\nD 城域网、局域网、广域网\n答案：C A. 局域网、广域网、城域网 - 错误。这个顺序与信号传输延迟的实际大小相反。\nB. 局域网、城域网、广域网 - 错误。城域网的延迟通常小于广域网。\nC. 广域网、城域网、局域网 - 正确。广域网的延迟最大，局域网的延迟最小。\nD. 城域网、局域网、广域网 - 错误。这个顺序与信号传输延迟的实际大小相反。\n99. 计算机病毒不可能潜伏在（）\nA 外存\nB 内存\nC 光盘\nD U 盘\n答案：C A. 外存 - 错误。计算机病毒可以潜伏在外存设备如硬盘和 USB 驱动器中。\nB. 内存 - 错误。虽然病毒在活动时占用内存，但它们通常不潜伏在内存中。\nC. 光盘 - 正确。如果光盘是只读的，病毒通常不会潜伏在其中。\nD. U 盘 - 错误。U 盘是一种外存设备，病毒可以潜伏在其中。\n100. 下列选项中，不属于音频播放软件是（）\nA Media Player\nB Winamp\nC RealPlayer\nD Dreamweaver\n答案：D A. Media Player - 错误。Windows Media Player 是一种音频和视频播放软件。\nB. Winamp - 错误。Winamp 是一种流行的音频播放软件。\nC. RealPlayer - 错误。RealPlayer 是一种音频和视频播放软件。\nD. Dreamweaver - 正确。Dreamweaver 是由 Adobe 公司开发的一款网页设计和开发软件，不是音频播放软件。\n","date":"5 September 2024","externalUrl":null,"permalink":"/cs_03_test/","section":"文章列表","summary":"本文是一套计算机基础知识 100 题的题库，适合计算机专业的学生学习。","title":"计算机基础知识 100 题","type":"blog"},{"content":"","date":"4 September 2024","externalUrl":null,"permalink":"/slug/cs_03/","section":"Slug","summary":"","title":"Cs_03","type":"slug"},{"content":" 计算机系统 # 计算机 （computer）：能够接收、存储、处理、输出数据的机器，俗称电脑。包括个人电脑、服务器（server）、超级计算机、工作站、嵌入式系统等。 PC（personal computer）：能够文档编辑、网页浏览、游戏等，个人计算机，通常运行操作系统如 Windows、macOS 或 Linux。 Mac：特指苹果公司生产的个人电脑，运行 macOS 操作系统。 早期：Mac \\(\\in\\) PC \\(\\in\\) Computer\nPC 这个术语最初是指个人电脑，但随着时间的发展，它在大众文化中通常被用来指代运行 Windows 操作系统的个人电脑。而 Mac 是苹果公司生产的个人电脑品牌，它们运行的是 macOS 操作系统。\n硬件 # 计算机的发展历史 # 机械计算时期（17世纪 - 19世纪）\n17世纪: 布莱兹·帕斯卡（Blaise Pascal）和戈特弗里德·莱布尼茨（Gottfried Leibniz）分别设计了早期的机械计算器（如Pascaline和莱布尼茨轮），用于执行简单的加减乘除运算。 19世纪: 查尔斯·巴贝奇（Charles Babbage）设计了“差分机”和“分析机”，这是最早的自动机械计算机概念，尽管由于技术限制，分析机从未完全建成。艾达·洛芙莱斯（Ada Lovelace）为巴贝奇的分析机编写了第一个算法，成为历史上第一位程序员。 电子计算机的萌芽（1930年代 - 1940年代）\n1930年代: 艾伦·图灵（Alan Turing）提出了图灵机的理论模型，为计算理论奠定了基础。约翰·阿塔纳索夫（John Atanasoff）和克利福德·贝里（Clifford Berry）开发了阿塔纳索夫-贝瑞计算机（ABC），这是第一台电子数字计算机的原型。\n1940年代: 世界上第一台通用电子数字计算机 ENIAC （Electronic Numerical Integrator and Computer）于 1946 年在美国建成。ENIAC 使用电子管，能够执行多种计算任务，但其体积庞大，耗电巨大。\n第一代计算机（1940年代末 - 1950年代中期）\n这一代计算机使用电子管作为基本逻辑元件，体积大、功耗高且不可靠。代表性计算机有UNIVAC I（1951年），这是第一台商用计算机。 编程使用机器语言或汇编语言，存储设备主要是磁鼓和打孔卡片。 第二代计算机（1950 年代中期 - 1960 年代中期）\n第二代计算机采用晶体管代替电子管，体积缩小，能耗降低，速度提升，可靠性增强。 使用高级编程语言（如Fortran和COBOL）编写程序，磁芯存储器和磁带开始作为主要的存储介质。 IBM 7090 和 UNIVAC 1108 是这一代计算机的代表。 第三代计算机（1960 年代中期 - 1970 年代初）\n使用集成电路 （IC）取代晶体管，使计算机进一步小型化和高效化。 操作系统开始普及，多道程序设计（multiprogramming）使得计算机可以同时处理多个任务。 IBM System/360 系列计算机是这一代的代表，它广泛应用于商业、科研和政府机构。 第四代计算机（1970年代初 - 现在）\n采用大规模集成电路（LSI）和超大规模集成电路（VLSI），计算机性能和存储容量进一步提升。 微处理器的发明（如 Intel 4004 和 8080）推动了个人计算机（PC）的发展，催生了计算机的普及化。 操作系统和图形用户界面（GUI）逐渐成为标准，个人电脑（如Apple II、IBM PC）迅速普及。 现代计算机与未来计算（21世纪）\n并行计算和云计算：分布式计算和云技术使得计算能力大幅度提升，允许大规模数据处理和人工智能的快速发展。 移动和嵌入式计算：智能手机、平板电脑、物联网设备等成为主流计算设备，嵌入式计算技术不断发展。 量子计算：量子计算机处于实验和早期应用阶段，有望解决传统计算机无法高效处理的复杂问题（如大规模因子分解和量子化学模拟）。 人工智能与机器学习：现代计算机借助于强大的计算能力和大数据，推动了人工智能、深度学习和神经网络的发展。 冯·诺依曼架构 # 1945 年冯·诺依曼提出了冯·诺依曼架构，这是现代计算机的基础，包括了存储程序概念。\n早期的计算机是由各种门电路组成的，这些门电路通过组装出一个固定的电路板，来执行一个特定的程序，一旦需要修改程序功能，就要重新组装电路板，所以早期的计算机程序是硬件化的！\n然而，祖师爷的出现将最初的硬件化程序变为可编程、可存储编码， 放在存储器中 ，随意使用\n冯·诺依曼架构理论要点\n数据都是二进制，bit（0/1）、byte，1 byte = 8 bit 计算机按照程序顺序执行 计算机由五大部分组成 进制转换\n二进制 十进制 五大部件：运算器、控制器、存储器、输入设备、输出设备\n运算器处理算数运算和逻辑运算、控制器指挥整个计算机（告诉运算器该处理什么数据），二者共同组成了中央处理器。\n存储器分为外部和内部，外部用来存储数据（硬盘）、内部直接和 CPU 交互（内存）\n计算机的分类 # 微型 大型 超大型 现代服务器常见硬件 # 现代服务器的硬件通常具有高性能、稳定性和可扩展性，旨在处理大量数据和提供可靠的计算能力。以下是现代服务器常见的硬件组件：\n中央处理器（CPU）\n服务器通常配备多个高性能多核处理器，如Intel Xeon系列或AMD EPYC系列，以提高并行处理能力。\n服务器CPU通常支持高级虚拟化和安全功能，提供更高的计算密度和能效。\n内存（RAM）\n服务器通常配备大量的内存，以支持大规模数据处理和多任务操作。常见的内存类型为DDR4或DDR5 ECC（错误纠正码）内存，以提高数据完整性和系统稳定性。\n内存容量通常在64GB到数TB不等，取决于应用需求和服务器的配置。\n存储设备\n固态硬盘（SSD）: 现代服务器越来越多地采用SSD（SATA、NVMe）作为存储介质，以获得更快的读写速度和更低的延迟。\n硬盘驱动器（HDD）: 尽管SSD流行，但HDD仍用于大容量存储解决方案，特别是在成本敏感的应用场景下。\nRAID控制器: 用于实现冗余和数据保护，支持各种RAID级别（如RAID 0, 1, 5, 6, 10）。\n主板\n服务器主板设计用于支持多CPU插槽、大量内存插槽、高速I/O扩展，以及各种管理和监控功能（如IPMI，Intelligent Platform Management Interface）。\n主板通常包括多个PCIe插槽用于扩展，例如增加GPU、存储控制器、网络适配器等。\n电源供应（PSU）\n服务器电源通常为冗余设计（如双电源），以保证系统的可靠性和持续运行能力。\n现代服务器电源通常为高效（80 PLUS金牌或铂金认证），以减少能源消耗和散热需求。\n网络接口卡（NIC）\n大多数服务器内置多个千兆以太网接口，有些高性能服务器支持10GbE、25GbE、40GbE，甚至100GbE接口，用于高速网络连接和数据传输。\n可以通过PCIe插槽扩展网络接口，增加带宽或支持不同的网络协议（如光纤通道，InfiniBand）。\n图形处理单元（GPU）\n专业的服务器通常配备高性能GPU卡（如NVIDIA Tesla、A100系列或AMD Radeon Instinct），用于加速AI/ML计算、数据分析、图形渲染和科学计算等任务。\nGPU服务器被广泛用于机器学习、深度学习、金融建模和科学模拟等高性能计算领域。\n机箱和冷却系统\n服务器机箱通常为标准化的机架式（如1U, 2U, 4U等）或刀片式设计，以便于数据中心内的安装和维护。\n配备强大的风冷系统或液冷系统，以确保在高负载下的散热性能。\n远程管理模块\n服务器通常配备基于BMC（Baseboard Management Controller）的远程管理模块，如IPMI、iDRAC（Dell）、iLO（HPE），用于监控和管理服务器的硬件状态、故障处理和固件升级。\n存储控制器\n用于管理磁盘阵列、缓存数据加速、优化读写性能，并支持不同的存储接口（如SATA、SAS、NVMe）。\n服务器中常见的存储控制器品牌有Broadcom、Intel、Microsemi等。\n固态硬盘缓存和加速卡\n专用的缓存和加速卡（如NVDIMM、Optane Memory）可以进一步加速存储性能和数据吞吐量，适用于需要高IOPS的应用场景。\n电池备份单元（BBU）\n用于在断电时保护缓存数据，通常与RAID控制器搭配使用，防止数据丢失。\n这些硬件组件结合在一起，为现代服务器提供了强大的计算、存储、网络和管理能力，能够支持各种企业级应用、云计算、虚拟化、大数据和AI/ML工作负载。\n软件 # 操作系统功能和分类 # 功能：\n硬件驱动 进程管理 内存管理 网络管理 安全管理 文件管理 分类：\n类型 操作系统 服务器 CentOS、Windows server、Ubuntu、Debian 桌面 Windows、Linux、macos 移动端 安卓、苹果、鸿蒙、 Unix 哲学思想 # 一切是文件（包括硬件） 小型、单一用途的程序 通过链接来完成复杂任务 避免复杂的界面 配置都可在文本中 Linux # Linux 历史\nLinus 开发内核，GNU 提供软件。\nLinux 发行版 ","date":"4 September 2024","externalUrl":null,"permalink":"/cs_03/","section":"文章列表","summary":"本文介绍计算机系统的组成及其发展历史。","title":"Day 3 计算机基础","type":"blog"},{"content":"","date":"3 September 2024","externalUrl":null,"permalink":"/slug/cs_02/","section":"Slug","summary":"","title":"Cs_02","type":"slug"},{"content":" 什么是服务器 # 关于一个网站 # 访问网站的基本原理 # 网站上线的基本要素 # 域名 # 服务器 # DNS # 服务器的基本用法 —— 网站部署 # 网站开发三剑客 # HTML CSS JavaScript 使用框架 # hexo hugo GitHub 简单介绍 # 白嫖 # 分享 # GitHub Page # ","date":"3 September 2024","externalUrl":null,"permalink":"/cs_02/","section":"文章列表","summary":"本文介绍了服务器和 GitHub 的基本概念，以及网站的基本原理、上线的基本要素、域名、服务器、DNS、网站开发三剑客、使用框架、GitHub 简单介绍、白嫖、分享、GitHub Page。","title":"Day 2 服务器和 GitHub 基本介绍","type":"blog"},{"content":"","date":"3 September 2024","externalUrl":null,"permalink":"/tags/%E7%BD%91%E7%AB%99/","section":"文章标签列表","summary":"","title":"网站","type":"tags"},{"content":"","date":"1 September 2024","externalUrl":null,"permalink":"/tags/debian/","section":"文章标签列表","summary":"","title":"Debian","type":"tags"},{"content":" 还没时间写 # ","date":"1 September 2024","externalUrl":null,"permalink":"/kvm-install-debian/","section":"文章列表","summary":"本文介绍了如何在 KVM 虚拟机中安装 Debian 系统。","title":"Debian 虚拟机的安装","type":"blog"},{"content":"","date":"1 September 2024","externalUrl":null,"permalink":"/slug/kvm-install-debian/","section":"Slug","summary":"","title":"Kvm-Install-Debian","type":"slug"},{"content":"","date":"1 September 2024","externalUrl":null,"permalink":"/series/linux/","section":"系列文章列表","summary":"","title":"Linux","type":"series"},{"content":"","date":"1 September 2024","externalUrl":null,"permalink":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/","section":"文章标签列表","summary":"","title":"虚拟机","type":"tags"},{"content":"","date":"31 August 2024","externalUrl":null,"permalink":"/slug/cs_01/","section":"Slug","summary":"","title":"Cs_01","type":"slug"},{"content":" 常用软件的安装 # 浏览器 # 浏览器 简介 优点 缺点 Firefox 一款开源的网页浏览器，注重隐私和用户定制化。 隐私保护、可定制化、开源社区支持，更新频繁 相比其他浏览器稍慢、某些网站兼容性问题 edge 微软开发的浏览器，集成 Windows 系统功能。 性能表现优秀、兼容性好 引导用户使用微软服务、扩展库较小 Chrome Google 开发，以其速度和简洁的用户界面闻名。 加载速度快、扩展程序具有安全性和稳定性 高内存占用、隐私方面的担忧（由于数据收集） 代码编辑器 # VSCode\nVSCode 是微软开发的开源代码编辑器，支持多种编程语言和强大的扩展功能。\n优点：广泛的扩展支持、轻量级且高效、集成开发工具、跨平台支持\n缺点：配置复杂、安装过多扩展可能影响性能、默认功能较少\n下载地址： https://code.visualstudio.com/Download\n虚拟机 # VMware\nVMware 是一家领先的虚拟化技术公司，提供多种虚拟化解决方案，包括虚拟机管理和云计算平台。\n优点：\n强大的虚拟化功能：支持多种操作系统和硬件环境，提供高效的资源管理。 广泛的企业支持：被许多大型企业和数据中心广泛使用，功能成熟。 高级功能：提供快照、克隆、迁移等高级虚拟化功能。 稳定性和性能：高稳定性和出色的性能，适合生产环境使用。 缺点：\n成本高：企业级产品和高级功能通常需要高昂的许可证费用。 学习曲线：高级功能和配置可能需要较长的学习时间和专业知识。 资源消耗：虚拟化会占用一定的系统资源，可能需要更高的硬件配置。 远程连接软件 # Xshell XFTP\nXshell 是一款功能强大的终端模拟器，支持多种协议（如 SSH、SFTP、TELNET）和多标签操作，主要用于远程管理和访问服务器。\n优点：多协议支持、多标签界面、强大的脚本功能、可自定义功能\n缺点：完整版需商业授权，一些功能学习曲线高\nXftp 是一款文件传输工具，与 Xshell 配合使用效果最佳，支持多种协议如 SFTP 和 FTP，用于在本地和远程服务器之间传输文件。\n优点：协议支持、拖放操作、多标签功能、集成 Xshell\n缺点：完整版是商业软件、传输时资源占用高\n终端工具 # Windows Terminal\nWindows Terminal 是微软开发的现代化终端应用程序，为 Windows 10 和 Windows 11 用户提供一个统一的命令行界面，支持多个终端和 shell，如 PowerShell、Command Prompt 和 Windows Subsystem for Linux (WSL)。\n优点：多标签支持、自定义功能、性能优化、开源\n缺点：功能复杂、依赖于 Windows 10/11\n配置一个顺手的浏览器 # 外观 # 可通过浏览器设置亮色暗色主题\n或者在插件市场安装主题\n插件 # 我目前在用的浏览器插件有：\n从上至下依次是：广告屏蔽插件、全局暗色主题、视频速度控制、kde 桌面支持、油猴脚本、站点分析\n书签栏 # 一个精心管理维护的书签栏会让你使用浏览器时得心应手\n如果你不想手动配置，那么还有优秀的导航网站供你选择\n网站 特点 程序员盒子 提供编程工具、资源和技术文章，聚焦于开发者工具和编程资源。 小众技术网 分享最新的技术工具和应用，关注小众技术和实用软件的推荐。 创意狮导航 提供丰富的工具和资源链接，聚焦于创意设计、开发工具和前端技术。 极光导航网 集中于网站资源和工具的导航，涵盖开发、设计、学习等多个领域。 柒夜导航网 提供简洁的资源导航，涵盖编程、设计、网络工具等，注重实用性和简洁性。 菜鸟教程网 提供大量编程教程和学习资源，涵盖多种编程语言和技术，适合初学者和进阶者。 配置一个顺手的编辑器（VSCode） # 主题 # 通过插件市场来安装\n我比较喜欢 GitHub Theme\n插件 # 建议安装的插件有\n从上到下功能依次是：括号彩色匹配、C 语言代码支持、主题、LaTeX 环境、markdown 环境、代码格式、SSH 连接\nLinux 新手生存指南 # Linux 虚拟机的安装 # Debian 镜像下载\nVMware 安装 Debian\n更改软件源\n快照的创建\n详情请参照我的这篇博客： Debian 虚拟机的安装\n基础的命令 # 命令 作用 pwd 显示当前工作目录的绝对路径。 cd 改变当前工作目录。 ls 列出指定目录下的文件和子目录。 cat 显示文件内容，或将多个文件的内容合并并显示。 find 在目录结构中查找文件或目录。 mkdir 创建一个新的目录。 touch 创建一个新的空文件，或更新现有文件的时间戳。 mv 移动或重命名文件和目录。 rm 删除文件或目录 tar 创建、查看或解压归档文件（如 .tar、.tar.gz）。 clear 清除终端屏幕上的内容。 好用的工具 # 命令 作用 sudo 以超级用户权限执行命令。 apt Debian 和 Ubuntu 系统上的包管理工具，用于安装、更新和删除软件包。 fish 一个现代化的、用户友好的命令行 shell。 neofetch 显示系统信息和一些有趣的 ASCII 艺术。 htop/btop 实时监控系统资源使用情况的交互式工具（`htop` 是传统工具，`btop` 是其改进版）。 vim 强大的文本编辑器，基于命令行，适用于代码和配置文件的编辑。 emacs 另一种功能强大的文本编辑器，具有扩展性和丰富的功能。 git 分布式版本控制系统，用于跟踪代码变更和协作开发。 wget 从网络上下载文件的工具，支持 HTTP、HTTPS 和 FTP 协议。 图形界面又不是不能用 # 初学者理解即可，后续勤加练习方可摆脱鼠标\n用 Xshell 连接 Linux # Linux 启动 SSH 服务\n安装 ssh 软件\nsudo apt install ssh 开机自启动 ssh 服务\nsudo systemctl enable --now ssh Xshell 傻瓜式操作不想写\n用 VSCode 连接 Linux # 打开 VSCode 中的 SSH 界面\n然后添加一个新连接，输入 ssh 连接的命令即可\n或者可以手动编写配置文件\n添加并保存好连接后，每次只需点击然后输入密码即可进入\n学习 markdown # 常用语法 # 网上有教程，不详细赘述\n本地记录笔记 # VSCode 中打开笔记存放文件夹 新建 .md 文件 打开预览 记录笔记 本地搭建一个自己的博客 # hexo 下载 # 首先安装 nodejs 和 npm\nsudo apt install nodejs 由于 npm 安装软件过慢，这里我们使用 pnpm （具有国内镜像）\n使用 npm 安装 pnpm\nsudo npm install -g pnpm 那么现在我们的包管理工具 pnpm 就下好了，然后通过 pnpm 安装 hexo\nsudo pnpm install -g hexo-cli 终端输入 hexo 验证是否成功安装\n主题的安装 # 选用主题为 butterfly ，可见作者的说明文档： https://butterfly.js.org/posts/21cfbf15/\nDay 2 预告 # Github 基础使用教程 # 网站上线 # ","date":"31 August 2024","externalUrl":null,"permalink":"/cs_01/","section":"文章列表","summary":"本文介绍了配置一个顺手的浏览器、代码编辑器、虚拟机、远程连接软件、终端工具的步骤。","title":"Day 1 初始环境的配置","type":"blog"},{"content":"","date":"31 August 2024","externalUrl":null,"permalink":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","section":"文章标签列表","summary":"","title":"环境配置","type":"tags"},{"content":"","date":"28 August 2024","externalUrl":null,"permalink":"/slug/math-01-01/","section":"Slug","summary":"","title":"Math-01-01","type":"slug"},{"content":"","date":"28 August 2024","externalUrl":null,"permalink":"/tags/%E9%9B%86%E5%90%88/","section":"文章标签列表","summary":"","title":"集合","type":"tags"},{"content":" 原文 # 在全国高考中，本节主要考查集合的概念、关系、运算等，下面梳理一些常考知识点.\n集合中元素的性质：确定性，互异性，无序性.\n集合间的基本关系\n关系 自然语言 符号语言 子集 集合 \\(A\\) 中所有元素都在集合 \\(B\\) 中 \\(A \\subseteq B\\) 真子集 集合 \\(A\\) 是集合 \\(B\\) 的子集，且集合 \\(B\\) 中至少有一个元素不在集合 \\(A\\) 中 \\(A \\subsetneqq B\\) 集合相等 集合 \\(A\\)，\\(B\\) 中的元素相同或集合 \\(A\\)，\\(B\\) 互为子集 \\(A=B\\) 子集个数：含有 \\(n\\) 个元素的集合的子集有 \\(2^{n}\\) 个，非空子集有 \\(2^{n}-1\\) 个，真子集有 \\(2^{n}-1\\)，非空真子集有 \\(2^{n}-2(n\\geq 1)\\) 个.\n集合的基本运算\n运算 自然语言 符号语言 并集 由所有属于集合 \\(A\\) 或属于集合 \\(B\\) 的元素组成的集合 \\(A\\cup B=\\{x\\mid x\\in A\\) 或 \\(x\\in B \\}\\) 交集 由属于集合 \\(A\\) 且属于集合 \\(B\\) 的所有元素组成的集合 \\(A\\cap B = \\{x\\mid x\\in A\\) 且 \\(x\\in B \\}\\) 补集 由全体 \\(U\\) 中不属于集合 \\(A\\) 的所有元素组成的集合 \\(\\complement_{U}A=\\{x\\mid x\\in U\\) 且 \\(x\\notin A\\}\\) 原文深度解析 # 概念 # 集合 (set) 简称集，是一个基本的数学模型[1] ，指若干[2] 不同[3] 对象[4] (object) 形成的总体.\n编号 名称 解释 举例 1 数学模型 是使用数学来将一个系统简化后予以描述 概率模型 2 若干 表示不定量 零、一、多、无限 3 不同 互不相同 \\(\\{\\frac{1}{2},0.5\\}\\) 不是集合 4 对象 任何被演绎推理和数学证明正式定义的对象 数、集合、函数、表达式、几何形状 其他细节：\n集合里的对象称作元素或成员，它们可以是任何类型的数学对象：数字、符号、变量、空间中的点、线、面，甚至是其他集合. 若 \\(x\\) 是集合 \\(A\\) 的元素，记作 \\(x\\in A\\). 不包含任何元素的集合称为空集；只包含一个元素的集合称为单元素集合. 集合可以包含有限或无限个元素. 如果两个集合所包含的元素完全相同，我们称这两个集合相等. 性质 # 集合元素的性质[1] 有确定性[2]，互异性[3]，无序性[4].\n编号 名称 解释 举例 1 元素的性质 元素之间的性质，不是指集合之间 集合没有互异性，两个集合可以相等 2 确定性 给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现. 比王俊凯帅的男孩不构成集合 3 互异性 一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。 4 无序性 一个集合中，每个元素的地位都是相同的，元素之间是无序的 互异性常考类型：集合相等\n已知 \\(\\{a,\\frac{b}{a},1\\}=\\{a^2,a+b,0\\}\\)，则 \\(a^{2022}+b^{2023}=\\)\n两种思考方式：\n从待定元素 \\(\\longrightarrow\\) 已知值\n当 \\(a=a^2\\) 时， \\(a=-1\\)\n当 \\(\\frac{b}{a}=a+b\\) 时，\\(b=\\frac{1}{2}\\) ，此时 \\(\\{-1,-\\frac{1}{2},1\\}=\\{1,-\\frac{1}{2},0\\}\\) 不符合题意. 当 \\(\\frac{b}{a}=0\\) 时，\\(b=0\\)，此时 \\(\\{-1,0,1\\}=\\{1,-1,0\\}\\) 符合题意 当 \\(a=a+b\\) 时，\\(b=0\\)，此时 \\(\\{a,0,1\\}=\\{a^2,a,0\\}\\)\n所以 \\(a^2=1\\) 则 \\(a=-1\\) 此时 \\(\\{-1,0,1\\}=\\{1,-1,0\\}\\) 符合题意\n当 \\(a=0\\) 时，不符合题意\n综上，\\(a=-1\\)，\\(b=0\\)\n从已知值 \\(\\longrightarrow\\) 待定元素\n从 \\(1\\) 出发\n当 \\(1=a^2\\) 时，\\(a=-1\\)，同上，\\(a=-1,b=0\\) 当 \\(1=a+b\\) 时，此时只能是 \\(b=0\\)，\\(a=1\\) 不符合题意 从 \\(0\\) 出发\n只能是 \\(b=0\\)，此时 \\(\\{a,0,1\\}=\\{a^2,a,0\\}\\)\n同上 \\(a=-1\\)\n综上，\\(a=-1\\)，\\(b=0\\)\n最优解：\n对比总结:\n选取最快的思考方法\n都有两个待定，如果由此进行分类讨论，情况太多，故选择从已知值 \\(\\longrightarrow\\) 待定元素\n选择最快的进入点\n如果从 \\(1\\) 开始，无法立即确定 \\(a^2\\) 是 \\(1\\) 还是 \\(a+b\\) 是 \\(1\\). 但从 \\(0\\) 开始，即可立即确定 \\(b=0\\)\n务必验证\n求出参数后，务必验证是否满足互异性\n集合之间的关系 # 空集 \\(\\varnothing\\)\n空集是什么：\n年龄大于 \\(200\\) 岁的活人 大于 \\(3\\) 小于 \\(2\\) 的实数 绝对值等于 \\(-1\\) 的实数 以上能构成集合，满足集合的性质，但不包含任何元素\n空集的简单考法：\n已知集合 \\(M=\\{x\\mid 2m\u0026lt;x\u0026lt;m+1\\}\\)，且 \\(M\\in \\varnothing\\)，则实数 \\(m\\) 的取值范围是：\n因为 \\(M\\) 是空集，则 \\(M\\) 中不包含任何元素，即小的反而大，大的反而小\n\\(2m\u0026gt;m+1\\) 还是 \\(2m\\ge m+1\\) ？\n大胆猜想，小心求证：先试一下 \\(2m=m+1 \\longrightarrow m=1\\) ，恰好 \\(m=1\\) 符合题意\n注意 ：\n问取值范围时要用集合来答，即取值范围是 \\(\\{m\\mid m\\ge 1\\}\\) 集合里有参数，注意空集 子集\n如果集合[1] \\(A\\) 中任意一个元素都属于集合[1] \\(B\\) ，则称集合 \\(A\\) 是集合 \\(B\\) 的子集\n编号 名称 解释 举例 1 集合是集合 子集的概念是集合与集合之间 元素不能是一个集合的子集 公式证明 # 证明：若集合 \\(A\\) 含有 \\(n\\) 个元素，则 \\(A\\) 的子集总个数为 \\(f(n)=2^n\\)\n证法 1 （分类法和递推公式）\n第一步：当集合 \\(A=\\varnothing\\) 时，其子集只有空集，\\(f(0)=2^0=1\\)，显然公式成立.\n第二步：当集合 \\(A\\ne \\varnothing\\) 时，设集合 \\(A=\\{a_1,a_2,a_3\u0026hellip;a_n \\}\\) 含有 \\(n\\) 个元素.\n则集合 A 的子集可分为两类.\n分类 描述 数学语言 第一类 不含有元素 \\(a_1\\) 的子集 \\(\\{a_2,a_3,\u0026hellip;,a_n\\}\\) 的所有子集 第二类 含有元素 \\(a_1\\) 的子集 举个例子：若 \\(A =\\{1,2,3,4\\}\\)\n则：\n\\(A\\) 的子集有：\\(\\{1234\\}\\) 、\\(\\{123\\}\\) 、\\(\\{124\\}\\) 、\\(\\{134\\}\\) 、\\(\\{234\\}\\) 、\\(\\{12\\}\\) 、\\(\\{13\\}\\) 、\\(\\{14\\}\\) 、\\(\\{23\\}\\)、\\(\\{24\\}\\) 、\\(\\{34\\}\\)、\\(\\{1\\}\\) 、\\(\\{2\\}\\) 、\\(\\{3\\}\\)、\\(\\{4\\}\\)、\\(\\{\\varnothing \\}\\)\n第一类有：\\(\\{234\\}\\)、\\(\\{23\\}\\)、\\(\\{24\\}\\)、\\(\\{34\\}\\)、\\(\\{2\\}\\)、\\(\\{3\\}\\)、\\(\\{4\\}\\)、\\(\\{\\varnothing \\}\\)\n第二类有：\\(\\{1234\\}\\)、\\(\\{123\\}\\)、\\(\\{124\\}\\)、\\(\\{134\\}\\)、\\(\\{12\\}\\)、\\(\\{13\\}\\)、\\(\\{14\\}\\)、\\(\\{1 \\}\\)\n第一类共有 \\((n-1)\\) 个元素，所以共有 \\(f(n-1)\\) 个子集。\n第二类可看作第一类每个子集都添加一个元素 \\(a_1\\) 而成，所以第二类子集个数 = 第一类子集个数 = \\(f(n-1)\\)\n又由于总子集个数 = 第一类 + 第二类，即\n\\[f(n)=f(n-1)+f(n-1)=2f(n-1)\\]\n重复应用上述递推公式可得：\n\\[f(n)=2f(n-1)=2 \\times 2f(n-2) = 2^2 f(n-2) = 2^n f(n-n) = 2^n f(0) = 2^n \\times 1 = 2^n\\]\n证毕！\n证法 2 （乘法计数原理）\n对于集合 \\(A\\) 中任意子集 \\(B\\)，那么集合 \\(A\\) 中元素 \\(a_i\\) 要么 \\(a_i \\in B\\) 要么 \\(a_i \\notin B\\).\n根据分步乘法计数原理，从 \\(a_1\\) 到 \\(a_i\\) 考虑 \\(n\\) 步，每一步都有 2 种可能的情况，故 \\(A\\) 的子集有 \\(2^n\\) 个.\n证法 3 （数学归纳法）\n第一步：当 \\(n=0,1\\) 时，\\(f(0)=1\\)，\\(f(1)=2\\) 显然公式成立.\n第二步：假设当 \\(n=k\\) 时公式成立，\\(f(k)=2^k\\)\n则当 \\(n=k+1\\) 时，可设 \\(A=\\{a_1,a_2,\u0026hellip;,a_{k+1}\\}\\)\n此时 \\(A\\) 的子集可分为两类\n分类 描述 子集个数 第一类 不含有 \\(a_{k+1}\\) 的子集 \\(\\{a_1,a_2,\u0026hellip;a_k\\}\\) 的子集 = \\(f(k)\\) 第二类 含有 \\(a_{k+1}\\) 的子集 \\(f(k)\\) 则 \\(f(k+1)=2f(k)=2^{k+1}\\)\n所以当 \\(n=k+1\\) 是公式也成立.\n最后根据数学归纳法原理可证得公式对于一切非负整数 \\(n\\) 都成立.\n证法 4 （组合数和二项式定理）\n二项式定理：\\((a + b)^n = \\binom{0}{n} a^n b^0 +\\binom{1}{n} a^{n-1} b^{1} + \u0026hellip; + \\binom{n}{n} a^0 b^n = \\sum_{k=0}^{n} \\binom{n}{k} a^{n-k} b^k\\)\n当 \\(a=b=1\\) 时，等式变为 \\((1+1)^n = 2^n = \\binom{0}{n} +\\binom{1}{n} + \u0026hellip; +\\binom{n}{n}\\) 组合数：从 \\(n\\) 个不同元素中，不管顺序抽出 \\(m\\) 个不同元素，其中组合种数称为组合数： \\(\\binom{m}{n} = \\frac{n!}{m! \\cdot (n-m)!}\\)\n首先，设 \\(A\\) 集合的元素个数为 \\(n\\)，其子集中的组成元素个数为 \\(k\\).\n当 \\(k=0\\) ：\\(\\varnothing \\longrightarrow \\binom{0}{n}\\)\n当 \\(k=1\\) ：\\(\\{a_1\\}\\)，\\(\\{a_2\\}\\) \u0026hellip; \\(\\{a_n\\}\\) \\(\\longrightarrow \\binom{1}{n}\\)\n当 \\(k=2\\) ：\\(\\{a_1,a_2\\}\\)，\\(\\{a_1,a_3\\}\\)，\\(\\{a_1,a_4\\}\\) \u0026hellip; \\(\\longrightarrow \\binom{2}{n}\\)\n当 \\(k=n\\) ：\\(\\{a_1,a_2,a_3\u0026hellip;a_n\\}\\longrightarrow \\binom{n}{n}\\)\n集合 \\(A\\) 的子集总个数为：\\(\\binom{0}{n} +\\binom{1}{n} + \u0026hellip; +\\binom{n}{n} = \\sum_{k=0}^{n} \\binom{k}{n} = 2^n\\)\n补充 # 常见数集 # 数集 符号 举例 自然数集 \\(N\\) \\(0,1,2,\\cdots\\) 正整数集 \\(N^+\\) \\(1,2,3,\\cdots\\) 整数集 \\(Z\\) \\(0,\\pm1,\\pm2,\\pm3,\\cdots\\) 有理数集 \\(Q\\) 实数集 \\(R\\) 有理数，无理数 复数集 \\(C\\) \\(i\\) 集合的表示方法 # 列举法\n举例 表示 大于 \\(1\\) 小于 \\(5\\) 的整数构成的集合 \\(\\{2,3,4\\}\\) 绝对值小于 \\(3\\) 的整数构成的集合 \\(\\{0,\\pm1,\\pm2\\}\\) 所有偶数构成的集合 \\(\\{0,\\pm2,\\pm4,\\pm6,\\cdots\\}\\) 第一象限的点所构成的集合 无法列举 描述法\n举例 表示 大于 \\(1\\) 小于 \\(5\\) 的整数构成的集合 \\(\\{ x\\mid 1 \u0026lt; x \u0026lt; 5,x\\in Z\\}\\) 或 \\(\\{x\\in Z\\mid 1 \u0026lt; x \u0026lt; 5\\}\\) 绝对值小于 \\(3\\) 的整数构成的集合 \\(\\{x\\mid \\lvert x\\rvert\u0026lt;3,x\\in Z\\}\\) 所有偶数构成的集合 \\(\\{x\\mid x=2k,k\\in Z\\}\\) 第一象限的点所构成的集合 \\(\\{(x,y) \\mid x\u0026gt;0,y\u0026gt;0,x\\in R,y\\in R\\}\\) ","date":"28 August 2024","externalUrl":null,"permalink":"/math-01-01/","section":"文章列表","summary":"本篇文章介绍了集合的概念及其性质，以及集合间的基本关系、子集个数、集合的基本运算等内容。","title":"模块一 集合","type":"blog"},{"content":"","date":"31 May 2024","externalUrl":null,"permalink":"/slug/my-home/","section":"Slug","summary":"","title":"My-Home","type":"slug"},{"content":"","date":"31 May 2024","externalUrl":null,"permalink":"/tags/%E9%A3%8E%E6%99%AF/","section":"文章标签列表","summary":"","title":"风景","type":"tags"},{"content":"","date":"31 May 2024","externalUrl":null,"permalink":"/tags/%E5%AE%B6%E4%B9%A1/","section":"文章标签列表","summary":"","title":"家乡","type":"tags"},{"content":" 本站所有与日常有关的文章如下（包括原创和转载）\n包括但不限于 梗 风景 日记 收藏 好物\n","date":"31 May 2024","externalUrl":null,"permalink":"/categories/%E6%97%A5%E5%B8%B8/","section":"文章分类列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站所有与日常有关的文章如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e包括但不限于 梗 风景 日记 收藏 好物\u003c/p\u003e","title":"日常","type":"categories"},{"content":" ","date":"31 May 2024","externalUrl":null,"permalink":"/my-home/","section":"文章列表","summary":"本篇文章介绍了我的家乡，以及我在那里的生活。","title":"我的家乡","type":"blog"},{"content":"","date":"12 January 2024","externalUrl":null,"permalink":"/series/algorithm/","section":"系列文章列表","summary":"","title":"Algorithm","type":"series"},{"content":"","date":"12 January 2024","externalUrl":null,"permalink":"/slug/algorithm_01/","section":"Slug","summary":"","title":"Algorithm_01","type":"slug"},{"content":"","date":"12 January 2024","externalUrl":null,"permalink":"/slug/algorithm_02/","section":"Slug","summary":"","title":"Algorithm_02","type":"slug"},{"content":"原系列视频作者链接： 【从0开始的C++算法课】第01期 | 递归(二) | 递归函数的缺陷 \u0026amp;\u0026amp; 引出递推算法\n有一对兔子，从出生后的第三个月起，每个月都生一对兔子，一对兔子成长到第三个月后每个月有生一对兔子，假如兔子都不死，问第 n 个月的兔子总数是多少对？\n我们只关心每月的兔子对数，列出观察发现其实就是斐波那契数列\n可以使用递归函数来解决，但需注意这个函数应该有两个起始项\nint f(int n) { int res; if (n == 1 || n == 2) { res = 1; } else { res = f(n - 1) + f(n - 2); } return res; } 接下来我们用 for 循环打印前 6 个月的兔子对数\nfor (int i = 1; i \u0026lt;= 6; i++) { printf(\u0026#34;month %d: %d\\n\u0026#34;, i, f(i)); } 但是这种算法有种缺陷，当月数变大时，程序计算结果的时间也就越长\n我们以第 6 个月举例\n可以看到有很多项在被重复计算着，于是随着求解的项数越多，程序执行的效率也就越低，于是我们可以不使用递归，每一次只用计算一遍便可提升执行效率\n定义一个整型数组 a 长度为 60 并初始化为 0，并将已经计算出结果月份存放在数组 a 中，可以使用 for 循环来完成数据的存放\nlong long a[60]={0}; a[1]=1; a[2]=1; for (int i = 3; i \u0026lt;= 50; i++) { a[i]=a[i-1]+a[i-2]; } 然后试着用 for 循环将前 50 月的结果全部输出\nfor (int i = 1; i \u0026lt;= 50; i++) { printf(\u0026#34;month %d: %lld\\n\u0026#34;, i, a[i]); } 可以明显地感受出差别，这种方式我们称之为递推，在数学中递推式同理\n在墙角按照规律堆放着一些完全相同的正方体小块，只要知道层数就可以知道所有小块的数量\n这里的规律就是除第一层，每一层都比上一层多了层数个的小块，可用 for 循环实现，记得初始化 level 和 sum 的值\nfor (int i = 2; i \u0026lt;= n; i++) { level = level + i; sum = sum + level; } 完整代码如下\n#include \u0026lt;stdio.h\u0026gt; int main() { int level = 1; int sum = 1; int n; printf(\u0026#34;Please enter a value for \u0026#39;n\u0026#39;: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; i++) { level = level + i; sum = sum + level; } printf(\u0026#34;%d\u0026#34;, sum); return 0; } 关于递推的两道习题\n题 1\n如果第十天有 1 个，那么第九天应该有 4 个，所以递推式如下\n第 n 项 = (第 n+1 项 + 1) *2\n全部代码如下\n#include \u0026lt;stdio.h\u0026gt; int main() { int a[15] = {0}; a[10] = 1; for (int i = 9; i \u0026gt;= 1; i--) { a[i] = (a[i + 1] + 1) * 2; } printf(\u0026#34;%d\u0026#34;, a[1]); return 0; } 题 2\n可以观察到分子分母都是斐波那契数列，于是我们可以用一个数组同时表示分子分母\n全部代码如下\n#include \u0026lt;stdio.h\u0026gt; int main() { int a[35] = {0}; a[1] = 1; a[2] = 1; for (int i = 3; i \u0026lt;= 35; i++) { a[i] = a[i - 1] + a[i - 2]; } int n; printf(\u0026#34;Please enter a value fot \u0026#39;n\u0026#39;(1 \u0026lt;= n \u0026lt;= 30): \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); double b[40] = {0}; double sum = 0; for (int i = 1; i \u0026lt;= n; i++) { b[i] = (double)a[i] / a[i + 1]; sum = sum + b[i]; } printf(\u0026#34;%.3f\u0026#34;, sum); return 0; } ","date":"12 January 2024","externalUrl":null,"permalink":"/algorithm_01/","section":"文章列表","summary":"本篇文章主要介绍递归函数的缺陷，引出递推算法，并用 for 循环和数组来求解斐波那契数列和分数求和。","title":"第01期 | 递归(二) | 递归函数的缺陷 \u0026\u0026 引出递推算法","type":"blog"},{"content":"原系列视频作者链接： 【从0开始的C++算法课】第02期 | 递推算法 | 经典题型解析 | 过河卒问题（递推算法求解）\n要求：\n输入：B 点坐标 (n,m)一级对方马 C 的坐标 (x,y) （马的坐标一定在棋盘范围之内，但可以落在边界上）\n输出：小卒从 A 点到 B 点的路径条数\n输入样例：6 6 3 2\n输出样例：17\n卒的行走规则只有向右和向下，当不考虑马的情况简单分析如下\nB 点和 A 点在同一行时路径只有 1 条\nB 点和 A 点在同一列时路径只有 1 条\n当 B 点在棋盘中间时，例如在 (1,1) 时，共有 先向下再向右 或者 先向右再向下 两条路径\n当 B 点在 (1,2) 时，共有 3 条路径\n分析可得，当 B 在中央时，路径条数总数是到达 B 所在位置上方和所在位置左方路径条数相加所得。想要知道到达上边或者左边的路径数就需要知道更上边或者更左边的路径数，可用递推表示。\n由于设计到坐标一般选择二维数组进行储值：数组名 [行数 n] [列数 m]\n并且提前规定 n = 0 或 m = 0 时 数组的值为 1，便可实现递推\nint a[30][30] = {0}; int n, m; printf(\u0026#34;Please enter two value for \u0026#39;n\u0026#39; and \u0026#39;m\u0026#39;: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { if (i == 0 \u0026amp;\u0026amp; j == 0) { continue; } if (i == 0 || j == 0) { a[i][j] = 1; } else { a[i][j] = a[i - 1][j] + a[i][j - 1]; } } } 以上只完成了没有马的情况下到达 B 点的路径条数，还需将马所在的 C 点及马的控制点 P 筛选出来\n我们可提前将整个 B 点所在的表格中数组标记为 1 再将 C 点及 P 点数组的值标记为 0，需要注意\n标记点是否存在于 B 点所在表格之内即阴影部分\n标记点是否超出棋盘范围\n可用简单的 if 语句判断\n以及马的本身也为 0\n但是如果当有任意一个马的控制点 P 占据了第 0 行和第 0 列的位置，就不能之间将第 0 行和第 0 列标记为 1 了，因为会被 P 点阻挡\n分析表格后发现，第 0 行的每个位置的值都等于它左边的值，第 0 列的每个位置的值都等于它上方的值\n完整修改代码如下：\n#include \u0026lt;stdio.h\u0026gt; int main() { int a[30][30] = {0}; int n, m, x, y; printf(\u0026#34;Please enter two value for \u0026#39;n\u0026#39; and \u0026#39;m\u0026#39;: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); printf(\u0026#34;Please enter two value for \u0026#39;x\u0026#39; and \u0026#39;y\u0026#39;: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { a[i][j] = 1; } } a[x][y] = 0; if (x + 2 \u0026lt;= n \u0026amp;\u0026amp; y - 1 \u0026gt;= 0) { a[x + 2][y - 1] = 0; } // P1 if (x + 2 \u0026lt;= n \u0026amp;\u0026amp; y + 1 \u0026lt;= m) { a[x + 2][y + 1] = 0; } // P2 if (x + 1 \u0026lt;= n \u0026amp;\u0026amp; y + 2 \u0026lt;= m) { a[x + 1][y + 2] = 0; } // P3 if (x - 1 \u0026gt;= 0 \u0026amp;\u0026amp; y + 2 \u0026lt;= m) { a[x - 1][y + 2] = 0; } // P4 if (x - 2 \u0026gt;= 0 \u0026amp;\u0026amp; y + 1 \u0026gt;= 0) { a[x - 2][y + 1] = 0; } // P5 if (x - 2 \u0026gt;= 0 \u0026amp;\u0026amp; y - 1 \u0026gt;= 0) { a[x - 2][y - 1] = 0; } // P6 if (x - 1 \u0026gt;= 0 \u0026amp;\u0026amp; y - 2 \u0026gt;= 0) { a[x - 1][y - 2] = 0; } // P7 if (x + 1 \u0026lt;= n \u0026amp;\u0026amp; y - 2 \u0026gt;= 0) { a[x + 1][y - 2] = 0; } // P8 for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { if (i == 0 \u0026amp;\u0026amp; j == 0) { continue; } if (a[i][j] == 0) { continue; } if (i == 0) { a[i][j] = a[i][j - 1]; } else if (j == 0) { a[i][j] = a[i - 1][j]; } else { a[i][j] = a[i - 1][j] + a[i][j - 1]; } } } printf(\u0026#34;%d\u0026#34;, a[n][m]); return 0; } 测试样例\n输入 6 6 3 2\n输出 17\n题目：使用递推求解\n","date":"12 January 2024","externalUrl":null,"permalink":"/algorithm_02/","section":"文章列表","summary":"本篇文章将介绍递推算法的基本概念，经典题型解析，以及过河卒问题的递推算法求解。","title":"第02期 | 递推算法 | 经典题型解析 | 过河卒问题（递推算法求解）","type":"blog"},{"content":"","date":"10 January 2024","externalUrl":null,"permalink":"/slug/algorithm_00/","section":"Slug","summary":"","title":"Algorithm_00","type":"slug"},{"content":"原系列视频作者链接： 【从0开始的C++算法课】第00期 | 环境搭建 \u0026amp; 递归 (一) | 基本数列递归\n需求：使用递归方式求解等差数列 1 4 7 10 13 … 第 n 项的值，要求输入 n 输出第 n 项的值\n首先定义函数 f ，输入的参数为整数 n ，对于这个等差数列返回结果依然为整数，所以返回结果为整数 res\n然后我们调用这个函数本身求出 res 的值，若输入的参数为 6 则函数计算流程如下\n可以看到整个过程是依次往前计算，但是我们知道数列没有第 0 项，因此递归函数不能没有限制\n递归需要有起始项，避免无限制递归，因此需要手动设置 n = 1 时的 res 值\nif (n == 1){ res = 1; } else{ res = f(n-1)+3; } 记得提前定义 res\n完整代码如下\n#include \u0026lt;stdio.h\u0026gt; int f(int n) { int res; if (n == 1) { res = 1; } else { res = f(n - 1) + 3; } return res; } int main() { int n; printf(\u0026#34;Please enter a value for \u0026#39;n\u0026#39;: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;The value of the %d item is: %d\u0026#34;, n, f(n)); return 0; } 作业\n题 1\n#include \u0026lt;stdio.h\u0026gt; int f(int n) { int res; if (n == 1) { res = 2; } else { res = f(n - 1) * 2; } return res; } int main() { int n; printf(\u0026#34;Please enter a value for \u0026#39;n\u0026#39;: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;The value of the %d item is: %d\u0026#34;, n, f(n)); return 0; } 题 2\n#include \u0026lt;stdio.h\u0026gt; int f(int n) { int res; if (n == 0 || n == 1) { res = 1; } else { res = f(n - 1) * n; } return res; } int main() { int n; printf(\u0026#34;Please enter a value for \u0026#39;n\u0026#39;: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;The factorial of %d is: %d\u0026#34;, n, f(n)); return 0; } ","date":"10 January 2024","externalUrl":null,"permalink":"/algorithm_00/","section":"文章列表","summary":"本篇文章介绍了环境搭建、递归的基本概念、基本数列递归的求解方法。","title":"第00期 | 环境搭建 \u0026 递归 (一) | 基本数列递归","type":"blog"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/slug/c_helloworld/","section":"Slug","summary":"","title":"C_helloworld","type":"slug"},{"content":"C 语言往往是我们接触到的第一门语言，而 HelloWorld 往往又是我们第一次运行的代码\n但是你真的了解C语言的 HelloWorld 吗？\n#include \u0026lt;stdio.h\u0026gt; // 我的第一个 C 语言程序 int main(int argc, char *argv[]) { printf(\u0026#34;Hello, World! \\n\u0026#34;); return 0; } 有的可能不写 return 0\n有的可能会将返回参数从 int 写成 void\n有的可能不写参数 ~~int argc, char *argv[]~~\n以上是一个最标准的 C 语言 HelloWorld 代码，写法上的差异放在最后讲解\n1、# 预处理 # 为预处理标示符，顾名思义是在编译之前执行的事情 # 以下为常见的预处理命令\n指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 1.1、#include # include 包含，#include 是一个预处理命令，用来引入头文件，效果是直接把头文件的内容复制在代码上方，可减少代码量\n2、.h 头文件 # 以 .h 为拓展名的是 C 语言的头文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。\n有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。\n要在程序中使用头文件，需要使用 C 预处理指令 #include 来引用它。\n引用头文件的语法有以下两种\n#include \u0026lt;file\u0026gt; #include \u0026#34;file\u0026#34; 2.1、stdio.h 文件 # std：代表符合 standard 标准 i：代表 input 输入 o：代表 output 输出 因此，“stdio.h” 是 C 语言标准库中的一个头文件，提供了标准输入输出的函数声明。\n这个头文件是由C语言标准规定的，因此是编译器自带的标准头文件之一。\n编译器自带的头文件放在 /usr/include/ 目录下\n可以看到 printf 函数被定义在这个文件中\n只有包含了stdio.h 头文件才能使用 printf 函数\n3、int main() # 在 C 语言中，main 函数是程序的入口点，也是程序执行的起始位置。每个 C 程序都必须包含一个 main 函数。当程序运行时，操作系统调用 main 函数来启动程序的执行。\nmain 函数的基本形式如下：\nint main(void) { // 代码块 return 0; // 可选的返回值，表示程序成功结束 } 这里有一些关键点：\n函数签名： main 函数的返回类型通常是整数类型，一般是 int。返回值可以用来指示程序的执行状态，一般约定返回 0 表示程序成功结束，而其他值则表示错误或异常情况。 参数： main 函数可以接受两个参数，用于处理命令行参数。 int main(int argc, char *argv[]) { // 代码块 return 0; } 或者可以使用不带参数的形式：\nint main(void){ // 代码块 return 0; } 注意，如果直接使用 int main() 在标准 C 中也是合法的，但有些编译器可能对参数的形式有一些要求。\n因此，如果你的编译器对带参数的 main 有特殊要求，可以选择使用 int main(void) 形式来明确表示不接受参数。\n代码块： main 函数的主体包含了程序的实际执行代码。这是程序的主要逻辑所在。\nprintf(\u0026#34;Hello World!); 返回值： return 0; 是可选的，但通常在 main 函数中使用，0 是程序正常的状态码，表示程序成功结束。其他非零的返回值通常用于指示程序异常结束或错误状态。\n整个程序的执行流程是从 main 函数开始，然后按照代码中的逻辑依次执行，直至 main 函数的末尾。\n4、本例中包含的 C 令牌（Token） # C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：\nprintf(\u0026#34;Hello, World! \\n\u0026#34;); printf：这是一个标识符（Identifier），表示调用的函数名。 (：这是一个左圆括号，表示函数调用的开始。 \u0026quot;Hello, World! \\n\u0026quot;：这是一个字符串常量，表示要被打印输出的字符串。 )：这是一个右圆括号，表示函数调用的结束。 ;：这是一个分号，表示语句的结束。 每个令牌在C语言中都有特定的含义和用途。这些令牌共同构成了一条C语句的结构。在上述例子中，printf 是一个函数调用语句，包含了一个字符串常量作为参数，然后以分号结束这条语句。\n4.1、标识符 # C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。\nC 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。下面列出几个有效的标识符：\nmohd zara abc move_name a_123myname50 _temp j a23b9 retVal 4.2、分号 ; # 在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。\n例如，下面是两个不同的语句：\nprintf(\u0026#34;Hello, World! \\n\u0026#34;); return 0; 在没有分号的情况下，编译器将无法正确解析代码结构，因此分号是 C 语言中必不可少的语法元素。\n4.3、// 注释 # 注释是用来提高代码可读性和维护性的工具，可以用于添加说明、临时禁用代码等。在编译时，注释的内容会被完全忽略。\n在 C 语言中，有两种主要的注释形式，分别是单行注释和多行注释。\n单行注释 使用 // 进行单行注释。在 // 出现的位置，其后的内容都被视为注释，直到该行结束。\n// 这是单行注释，这一行的内容都是注释 int main() { // 这是 main 函数 printf(\u0026#34;Hello, world!\\n\u0026#34;); // 这是打印语句 return 0; // 返回 0 表示程序正常结束 } 多行注释 使用 /* 开始注释块，使用 */ 结束注释块。注释块中的所有内容都被视为注释。\n/*这是多行注释*/ int main() { /* 这是 main 函数 这是另一个注释块 */ printf(\u0026#34;Hello, world!\\n\u0026#34;); /* 这是打印语句 */ return 0; /* 返回 0 表示程序正常结束 */ } 单行注释只在当前行有效，而多行注释可以跨越多行。\n注释不能嵌套使用，例如 /* /* 这是注释 */ */ 是不合法的。\n5、转义字符 # 在 C 语言中，转义字符是一种特殊的字符序列，用于表示一些无法直接输入或打印的字符。转义字符以反斜杠（\\）开头，后跟一个或多个字符。\n转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限：\n八进制形式的转义字符最多后跟三个数字，也即\\ddd，最大取值是\\177； 十六进制形式的转义字符最多后跟两个数字，也即\\xdd，最大取值是\\x7f。 超出范围的转义字符的行为是未定义的，有的编译器会将编码值直接输出，有的编译器会报错。\n不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下：\n转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) 009 \\v 垂直制表(VT) 011 ' 单引号 039 \u0026quot; 双引号 034 \\ 反斜杠 092 例如，本例中提到的 \u0026quot;Hello, World! \\n\u0026quot; 中的 \\n 表示换行符，使得在输出字符串后会在控制台中换行显示。\n6、总结 # 包含头文件： #include \u0026lt;stdio.h\u0026gt; 表示引入标准输入输出库的头文件，其中包含了 printf 函数的声明。 注释： // 我的第一个 C 语言程序 是一个单行注释，用于提供对程序的简要描述。 main 函数： int main(int argc, char *argv[]) 是程序的入口点。argc 表示命令行参数的数量，argv 是一个指向字符串数组的指针，存储了实际的命令行参数。 printf 函数： printf(\u0026quot;Hello, World! \\n\u0026quot;); 是一个输出语句，它将字符串 “Hello, World!” 和一个换行符打印到标准输出设备（通常是控制台）。 返回值： return 0; 表示 main 函数成功执行并正常结束，返回值为 0。在 C 语言中，返回值为 0 通常表示程序成功执行。 这个程序的主要目的是输出 “Hello, World!” 到控制台，这是一个传统的、用于学习编程语言的入门示例。\n💡 **到此本例详解结束** 争论写法上的差异问题（仅代表个人看法） # int main 还是 void main ? 标准规定 main 函数返回一个整数值，通常用于指示程序的执行状态。返回值为 0 通常表示程序正常结束，而其他非零值则表示程序异常结束或错误状态。\n因此，正确的形式是：\nint main() { // 你的代码 return 0; } 不推荐使用 void main()，因为根据 C 语言标准，main 函数应该返回一个整数值。虽然有些编译器可能会接受 void main()，但这并不是标准的写法，可能导致不同编译器之间的兼容性问题。\n该不该写 main 函数的那两个参数？ 在 C 语言中，main 函数的标准形式是带有参数，即 int main(int argc, char *argv[])\n然而，如果你选择不写这两个参数，编译器通常也会接受。\n// 如本例中完全可以不写两个参数 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } 这个程序是合法的，并且在很多编译器中会正常工作。\n在这个特定的例子中，省略了 argc 和 argv 参数，因为这个简单的程序没有使用命令行参数。\n在实际应用中，是否使用带参数的 main 函数取决于你的程序是否需要处理命令行输入。如果不需要，可以使用不带参数的形式。\n不写 return 0 会怎么样? 按照约定，返回值为 0 表示程序正常结束，而其他非零值通常表示程序发生了错误或异常情况。如果省略 return 语句，编译器通常会默认返回 0，但一些编译器可能会给出警告，因为这样的代码可能会让人误解程序的执行状态。\n强烈建议在 main 函数中使用 return 语句，以提高代码的清晰性和可读性。\n在这个例子中，虽然缺少了 return 0;，但许多编译器仍然会默认认为程序正常结束，返回值为 0。然而，最好养成良好的编程习惯，在 main 函数中明确指定返回值。\n","date":"20 December 2023","externalUrl":null,"permalink":"/c_helloworld/","section":"文章列表","summary":"本文将逐字符讲解 C 语言 HelloWorld 程序，并详细介绍 C 语言的基本语法和常用预处理命令。","title":"逐字符讲解 C 语言 HelloWorld 程序","type":"blog"},{"content":"","date":"9 September 2023","externalUrl":null,"permalink":"/slug/anki/","section":"Slug","summary":"","title":"Anki","type":"slug"},{"content":"在现代社会，无论是学生、专业人士，还是任何渴望学习新知识的人，记忆都是学习过程中至关重要的一环。许多人在学习中会遇到记忆难题：背了忘，忘了背，形成了一个低效循环。幸运的是，有一个工具可以帮助我们打破这个循环，那就是 Anki。\n什么是 Anki？ # Anki 是一款基于间隔重复（Spaced Repetition）原理的开源记忆软件。它的名字源于日语“暗記”（anki），意为“记忆”。与传统的死记硬背方法不同，Anki 通过科学的算法来优化学习时间，让你在记忆遗忘之前适时复习，从而达到最佳记忆效果。\n为什么选择 Anki？ # 1. 间隔重复：科学高效的记忆法 # Anki 的核心理念是间隔重复法，这是一种基于认知科学的记忆方法。它根据艾宾浩斯遗忘曲线原理，利用算法计算出你每次复习的最佳时间间隔。当你正确记住一个知识点时，Anki 会适当地延长你下次复习的时间间隔；而当你忘记时，它会缩短这个间隔。这样，你可以在记忆开始衰退时迅速巩固记忆，有效防止知识点遗忘。\n2. 完全自定义化 # Anki 支持完全的自定义化。你可以创建自己的学习卡片（称为“卡片集”或“Decks”），包括正面和背面内容。你可以添加文本、图像、音频、甚至视频，从而适应各种不同学习需求。无论你是在学习语言、医学、历史，还是其他任何学科，Anki 都能帮助你构建适合自己的记忆工具。\n3. 多平台同步 # Anki 支持多平台使用，包括 Windows、macOS、Linux、iOS 和 Android。更棒的是，所有设备间的数据都可以通过 AnkiWeb 实现云同步。这意味着你可以随时随地在任何设备上进行学习，而不必担心数据丢失或进度不同步。\n4. 强大的插件系统 # Anki 的插件系统非常强大，社区也十分活跃。你可以根据需要安装各种插件来增强 Anki 的功能。例如，有的插件可以帮助你在卡片中插入 LaTeX 公式，适合需要记忆数学公式的用户；还有的插件可以美化卡片界面，或者增强统计功能，让你更好地了解自己的学习进度和效果。\n5. 广泛的学习社区与资源共享 # Anki 的用户遍布全球，形成了一个庞大的学习社区。你可以在社区中找到各种各样的学习卡片集资源，从语言学习（如托福、雅思、日语等）到医学考试、计算机科学等等，应有尽有。你可以直接下载并使用这些高质量的卡片集，节省自己制作卡片的时间。\n如何开始使用 Anki？ # 下载安装 Anki：访问 Anki官网 下载适合你操作系统的版本。\n创建卡片集：安装完成后，创建一个新的卡片集，并开始添加你需要记忆的内容。\n定期复习：Anki 会根据你的记忆情况，自动安排复习时间。你只需按照安排进行学习，便可以达到最佳记忆效果。\n探索插件和社区资源：根据自己的学习需求，安装相应的插件，并加入 Anki 社区，下载现成的卡片集资源。\n结语 # Anki 是一个强大且灵活的学习工具，可以帮助任何人更高效地记忆信息。无论你是学生、专业人士，还是终身学习者，Anki 都能助你一臂之力。通过科学的间隔重复方法，自定义的学习卡片，多平台支持和丰富的社区资源，你可以将记忆变成一种轻松而高效的过程。赶快试试 Anki，开启你的高效记忆之旅吧！\n","date":"9 September 2023","externalUrl":null,"permalink":"/anki/","section":"文章列表","summary":"本文介绍了 Anki 软件，并简要介绍了它的特点、适用场景、使用方法。","title":"Anki：记忆神器，助你高效学习","type":"blog"},{"content":"","date":"9 September 2023","externalUrl":null,"permalink":"/tags/%E8%AE%B0%E5%BF%86/","section":"文章标签列表","summary":"","title":"记忆","type":"tags"},{"content":"","date":"9 July 2023","externalUrl":null,"permalink":"/tags/gentoo/","section":"文章标签列表","summary":"","title":"Gentoo","type":"tags"},{"content":" Gentoo Linux 从入门到入土\n前言 # 本文档仅为本人当笔记使用，内容仅供参考。不定期更新。\n内容 # 打算分三部分，第一部分是 Gentoo 的安装，第二部分是 Bspwm 窗口管理器的配置，第三部分是软件工具的安装。\n声明 # 本人菜鸟一个，用 Linux 只是因为有受不了 Windows ，用 Gentoo 只是为了浪费生命（Doge），以下内容仅为本人在学习过程中的记录，主要目的为了以后我自己安装 Gentoo 时的参考，各位参考需谨慎。\nGentoo 的基本安装 # 安装介质的准备 # 在开始之前，我们首先列出在 amd64 机器上成功安装 Gentoo 所需的硬件要求。\n下载最新官方镜像（可选清华大学镜像源）\n将 install-amd64-minimal-*.iso 刻录到 U 盘中（推荐全平台制作工具 BalenaEtcher）\n重启电脑并设置 U 盘为第一引导，进入 U 盘安装系统。\n重启电脑后进 U 盘安装模式 # 键盘设置默认回车，中国电脑使用US键盘（默认）\n之后正式进入安装界面，输入以下命令测试是否是 UEFI 引导启动，有输出结果即为 UEFI 启动。\nls /sys/firmware/efi/efivars 网络方面的设置 # # 检查网卡ifconfig# 检查网络连接ping -c 3 www.baidu.com 磁盘空间准备阶段 # 在本阶段中，首先要完成分区，利用 fdisk 工具或 cfdisk 工具完成磁盘空间分配。在本次安装中，采用的电脑为 4 核 8 线程，运行内存为 16 G，固态硬盘容量 256G。采用的分配方案如下\nFilesystem Size Mounted on Type /dev/nvme0n1p1 512M /boot vfat /dev/nvme0n1p2 8G [SWAP] swap /dev/nvme0n1p3 64G / btrfs /dev/nvme0n1p4 160.4G /home xfs 做好分区划分后，对应地进行格式化与挂载\n# 启动交换分区mkswap /dev/nvme0n1p2swapon /dev/nvme0n1p2# 根分区mkdir --parents /mnt/gentoomkfs.btrfs /dev/nvme0n1p3mount /dev/nvme0n1p3 /mnt/gentoo# 引导分区mkdir /mnt/gentoo/bootmkfs.vfat -F 32 /dev/nvme0n1p1mount /dev/nvme0n1p1 /mnt/gentoo/boot# home 分区mkdir /mnt/gentoo/homemkfs.xfs /dev/nvme0n1p4mount /dev/nvme0n1p4 /mnt/gentoo/home 下载安装文件 # 手动配置当前时间\ndate 100313162023 进入挂载点，下载 stage3 并解压，其中的 stage3 包可以从 Gentoo 官网或者 清华源 下载，这里选择了stage3-amd64-desktop-openrc 。\n# 进入挂载目录cd /mnt/gentoo# 下载 stage3wget https://mirrors.tuna.tsinghua.edu.cn/gentoo/releases/amd64/autobuilds/current-stage3-amd64-desktop-openrc/stage3-amd64-desktop-openrc-**.tar.xz# 解压 stage3tar xpvf stage3-*.tar.xz --xattrs-include=\u0026#39;*.*\u0026#39; --numeric-owner 之后开始配置编译选项\n# 编辑 make.conf 文件nano -w /mnt/gentoo/etc/portage/make.conf # Build-time functionality# ========================#USE=\u0026#34;X elogind alsa pulseaudio vulkan pgo lto zstd vaapi vdpau opengl dbus cjk udev\u0026#34;# Host Setting# ============#CHOST=\u0026#34;x86_64-pc-linux-gnu\u0026#34;# Host and optimization settings# ==============================#COMMON_FLAGS=\u0026#34;-march=native -O2 -pipe\u0026#34;CFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34;CXXFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34;FCFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34;FFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34;# Advanced Masking# ================#ACCEPT_KEYWORDS=\u0026#34;amd64\u0026#34;ACCEPT_LICENSE=\u0026#34;*\u0026#34;# Portage Directories# ===================#PORTAGE_TMPDIR=/var/tmpPORTDIR=/var/db/repos/gentooDISTDIR=/var/cache/distfilesPKGDIR=/var/cache/binpkgs# Fetching files# ==============#GENTOO_MIRRORS=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/gentoo\u0026#34;# Advanced Features# =================#EMERGE_DEFAULT_OPTS=\u0026#34;--keep-going --with-bdeps=y --complete-graph --jobs=2 -l\u0026#34;MAKEOPTS=\u0026#34;-j2\u0026#34;AUTOCLEAN=\u0026#34;yes\u0026#34;# 安装了 ccache 后再启用以下两行FEATURES=\u0026#34;ccache\u0026#34;CCACHE_DIR=\u0026#34;/var/cache/ccache\u0026#34;# Language# ========#LC_MESSAGES=C.utf8L10N=\u0026#34;en-US zh-CN en zh\u0026#34;LINGUAS=\u0026#34;en_US zh_CN en zh\u0026#34;# Bootloader# ==========#GRUB_PLATFORMS=\u0026#34;efi-64\u0026#34;# Xorg Devices# ============#INPUT_DEVICES=\u0026#34;libinput\u0026#34;VIDEO_CARDS=\u0026#34;amdgpu radeonsi\u0026#34;# 虚拟机方面设置，按需配置# QEMU Targets# ============#QEMU_SOFTMMU_TARGETS=\u0026#34;arm x86_64 sparc\u0026#34;QEMU_USER_TARGETS=\u0026#34;x86_64\u0026#34; 安装 Gentoo 基本系统 # 配置 ebuild 软件仓库\n# 创建repos.conf 目录mkdir --parents /mnt/gentoo/etc/portage/repos.conf# 将 Portage 提供的 Gentoo 存储库配置文件复制到（新创建的）repos.conf 目录cp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf 修改源\n# 编辑配置文件，替换以下内容nano /mnt/gentoo/etc/portage/repos.conf/gentoo.conf sync-uri = rsync://rsync.mirrors.tuna.tsinghua.edu.cn/gentoo-portage/ 复制DNS信息\ncp --dereference /etc/resolv.conf /mnt/gentoo/etc/ 安装必要的文件系统，需要提供的文件系统是：\n/proc/ 这是一个伪文件系统（它看起来像普通文件，但实际上是动态生成的），Linux 内核从中向环境公开信息 /sys/ 是一个伪文件系统，就像 /proc/ 一样，它曾经打算取代它，并且比 /proc/ 更有结构 /dev/ 是一个常规文件系统，部分由 Linux 设备管理器（通常是 udev）管理，其中包含所有设备文件 /run/ 是一个临时文件系统，用于运行时生成的文件，例如PID文件或锁\nmount --types proc /proc /mnt/gentoo/procmount --rbind /sys /mnt/gentoo/sysmount --rbind /dev /mnt/gentoo/devmount --bind /run /mnt/gentoo/run 进入新环境\nchroot /mnt/gentoo /bin/bashsource /etc/profileexport PS1=\u0026#34;(chroot) ${PS1}\u0026#34; 安装ebuild数据库快照\nemerge-webrsyncemergr --sync 选择系统配置文件\neselect profile listeselect profile set x 安装 cpuid2cpuflags，检测 cpu 指令集（如果安装不了，请先更新 world）\nemerge --ask app-portage/cpuid2cpuflagsecho \u0026#34;*/* $(cpuid2cpuflags)\u0026#34; \u0026gt; /etc/portage/package.use/00cpu-flags 安装 ccache 加快编译速度\nemerge -av ccachemkdir -p /var/cache/ccachechown root:portage /var/cache/ccache -Rchmod 2775 /var/cache/ccache -R# 编写配置文件nano /var/cache/ccache/ccache.conf # /var/cache/ccache/ccache.confmax_size = 100.0Gumask = 002hash_dir = falsecompiler_check = %compiler% -vcache_dir_levels = 3compression = truecompression_level = 1 安装aria2加快emerge的下载速度(可选)\nemerge -av aria2 在 make.conf 中添加如下内容\nFETCHCOMMAND=\u0026#34;/usr/bin/aria2c -d \\${DISTDIR} -o \\${FILE} --allow-overwrite=true --max-tries=5 --max-file-not-found=2 --max-concurrent-downloads=5 --connect-timeout=5 --timeout=5 --split=5 --min-split-size=2M --lowest-speed-limit=20K --max-connection-per-server=9 --uri-selector=feedback \\${URI}\u0026#34;RESUMECOMMAND=\u0026#34;${FETCHCOMMAND}\u0026#34; 现在可以更新 world 了\nemerge --ask --verbose --update --deep --newuse @worldetc-update --automode -3 完了以后设置时区与语言\necho \u0026#34;Asia/Shanghai\u0026#34; \u0026gt; /etc/timezoneemerge --config sys-libs/timezone-dataecho \u0026#34;en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8\u0026#34; \u0026gt;\u0026gt; /etc/locale.genlocale-geneselect locale list# 设置成英文eselect locale set X# 现在重新加载环境env-update \u0026amp;\u0026amp; source /etc/profile \u0026amp;\u0026amp; export PS1=\u0026#34;(chroot) ${PS1}\u0026#34; 配置与编译内核 # 先采取二进制内核，进入系统之后再进行自定义编译\n# 开启 initramfs USE 以便获取 amd-uc.imgecho \u0026#34;sys-kernel/linux-firmware initramfs\u0026#34; \u0026gt;\u0026gt; /etc/portage/package.use/linux-firmwareemerge -av sys-kernel/linux-firmware# 安装二进制内核emerge -av sys-kernel/gentoo-kernel-bin# 安装 genkernel 以便生成 initramfs 文件emerge -av genkernelgenkernel initramfs --compress-initramfs --makeopts=-j`nproc`# 检查是否生效，应出现 amd-uc.img initramfs*.img vmlinuz*.img config* System.map* 这些文件ls /boot/ 配置系统 # 生成fstab\n# 安装 genfstab 以便自动配置 fstabemerge -av sys-fs/genfstabgenfstab -U / \u0026gt;\u0026gt; /mnt/gentoo/etc/fstab# 检查是否全部正确cat /etc/fstab 设置主机名（OpenRC 或 systemd）\necho Gentoo-WorkSpace \u0026gt; /etc/hostname 编辑 hosts 文件\nnano /etc/hosts # /etc/hosts: Local Host Database127.0.0.1 Gentoo-WorkSpace.homenetwork Gentoo-WorkSpace localhost::1 localhost 设置 Root 密码\npasswd 设置时钟选项\n# 编辑 hwclock 文件，更改 clock=\u0026#34;local\u0026#34;nano /etc/conf.d/hwclock 安装系统工具 # # 系统记录器emerge --ask app-admin/sysklogdrc-update add sysklogd default# 定时守护进程emerge --ask sys-process/cronierc-update add cronie default# 文件索引emerge --ask sys-apps/mlocate# 时间同步emerge --ask net-misc/chronyrc-update add chronyd default# 文件系统工具emerge -av sys-fs/xfsprogsemerge -av sys-fs/btrfs-progsemerge --ask sys-block/io-scheduler-udev-rules# 网络工具emerge --ask net-misc/dhcpcdrc-update add dhcpcd defaultrc-service dhcpcd startemerge --ask net-wireless/iw net-wireless/wpa_supplicant 配置引导加载程序 # 安装 GRUB 之前检查 make.conf 中是否设置了 GRUB_PLATFORMS=“efi-64”\nemerge --ask sys-boot/grubgrub-install --target=x86_64-efi --efi-directory=/bootgrub-mkconfig -o /boot/grub/grub.cfg# 以下为正确的反馈，即 GRUB 可以找到识别内核文件和 initramfs 文件Generating grub.cfg ...Found linux image: /boot/vmlinuz-5.15.52-gentooFound initrd image: /boot/initramfs-genkernel-amd64-5.15.52-gentoodone 重新启动系统\nexitcdumount -l /mnt/gentoo/dev{/shm,/pts,}umount -R /mnt/gentooreboot 简单设置新系统 # 添加日常使用的用户\nuseradd -m -G users,wheel,audio -s /bin/bash qlad# 为 qlad 用户设置密码，这里密码规则较复杂passwd qlad 磁盘清理\nrm /stage3-*.tar.* Bspwm 窗口管理器 # 安装相关软件 # # 安装 xorg-serveremerge --ask x11-base/xorg-server# 在启动运行级别启动 elogindrc-update add elogind boot# 编辑 .xinitrc 文件 添加 exec bspwmnano ~/.xinitrc# 安装 Bspwmemerge --ask x11-wm/bspwm 使用我的 Dot 文件 # git clone [https://github.com/qlad/dotfiles.git](https://github.com/qlad/dotfiles.git)cp -r .config/ ~/.config/ 重启系统，在 tty 里输入 startx 检验是否成功 # 软件工具的安装 # 待更。。。。。。。\n","date":"9 July 2023","externalUrl":null,"permalink":"/gentoo_bak/","section":"文章列表","summary":"本文为 Gentoo 学习笔记，主要介绍 Gentoo 的安装、Bspwm 窗口管理器的配置、软件工具的安装。","title":"Gentoo 学习笔记","type":"blog"},{"content":"","date":"9 July 2023","externalUrl":null,"permalink":"/slug/gentoo_bak/","section":"Slug","summary":"","title":"Gentoo_bak","type":"slug"},{"content":"","date":"22 February 2023","externalUrl":null,"permalink":"/en/categories/english/","section":"Article Category List","summary":"","title":"English","type":"categories"},{"content":"","date":"22 February 2023","externalUrl":null,"permalink":"/en/tags/english/","section":"Article Tag List","summary":"","title":"English","type":"tags"},{"content":"Learn to write an English blog from now on.\n","date":"22 February 2023","externalUrl":null,"permalink":"/en/start-english/","section":"Article List","summary":"This is the first post of English blog","title":"Learn to blog in English","type":"blog"},{"content":"","date":"22 February 2023","externalUrl":null,"permalink":"/en/slug/start-english/","section":"Slug","summary":"","title":"Start-English","type":"slug"},{"content":"没钱买软路由，尝试虚拟机安装 OpenWRT 系统\n说明 # 本人家庭网络环境 # 一条电信宽带，两个路由器，都是硬路由\n由于一些特殊需求，需要直接给路由器安装插件，实现某一功能（Open Clash），但是家里路由器都是硬路由（家庭常见路由器都是硬路由：TPLink，华为路由器）所以没法刷第三方 OpenWRT 固件，于是乎想到了 KVM 虚拟机安装 OpenWRT 系统来实现软路由\n优点 # 无需任何经济成本，硬件自定义配置\n缺点 # 电脑关机则不能使用 KVM 虚拟机，所以 OpenWRT 不能 7*24 小时工作\n前提介绍（环境配置） # 什么是软路由？ # 软路由是指利用台式机或服务器配合软件形成路由解决方案，主要靠软件的设置，达成 路由器 的功能；而 硬路由 则是以特有的硬设备，包括处理器、电源供应、 嵌入式软件，提供设定的路由器功能。—— 《百度百科》\n简单理解就是在任何一台电脑上安装一个可当作路由器的系统，市面上卖的软路由其实上就是一台微型电脑。\n我的电脑环境？ # 宿主机：Arch Linux + KVM (QEMU)\n网络设置：Arch 通过有线网络连到副路由器上，副路由器和主路由器进行桥接模式（如果不是桥接模式的话，副路由器给 Arch 分配的 IP 地址就和主路由器一样，但是我需要把 OpenWRT 作为副路由器的旁路由来使用）\n下图为我的 TpLink 路由器设置桥接模式的页面\nhttps://s2.loli.net/2022/08/04/ViCQu5ZsjoOJTUb.png\nArch 宿主机的网络配置 # 创建一块虚拟桥接模式的网卡，以供 OpenWRT 虚拟机使用\n(参考：Arch Linux Wiki : Network bridge)\n1、先新建一块桥接模式的虚拟网卡 br0\nnmcli connection add type bridge ifname br0 stp no 2、使有限网接口（enp30s0 改成你自己的有限网接口）成为网桥的从属：\nnmcli connection add type bridge-slave ifname enp30s0 master br0 3、将新建的桥接线路设置为开启\nnmcli connection up bridge-br0 nmcli connection up bridge-slave-enp30s0 正式开始安装 # 1、下载固件 # 我用的是一个可以在线编译的网站，上也有编译好的版本\nOpenWrt固件下载与在线定制编译\nhttps://s2.loli.net/2022/08/04/ph51ZF6qPYTVkAS.png\n2、采用图形化 virt-manager 安装 # 2.1、选择导入磁盘镜像\nhttps://s2.loli.net/2022/08/04/ZgG8BJAXcS9DVL4.png\n2.2、选择版本为其他 OS\nhttps://s2.loli.net/2022/08/04/2q1WS4ljAtdbwGM.png\n2.3、自定义 OpenWRT 虚拟机硬件配置\nhttps://s2.loli.net/2022/08/04/dwLauIZCl4BeMrA.png\n2.3、设置网络为 br0\nhttps://s2.loli.net/2022/08/04/3TbYgxIm4XM2liD.png\n2.4、完成安装\nhttps://s2.loli.net/2022/08/04/pwcPAK9OjDyGInd.png\nOpenWRT 配置 # 设置 OpenWRT 的 IP 地址，这里随便设置成你网段中的任意一个不被占用的地址\nvim /etc/config/network config interface \u0026#39;lan\u0026#39; option type \u0026#39;bridge\u0026#39; option ifname \u0026#39;eth0\u0026#39; option proto \u0026#39;static\u0026#39; option ipaddr \u0026#39;192.168.0.132\u0026#39; #副路由 192.168.101.2,旁路由我设置 192.168.101.132 option netmask \u0026#39;255.255.255.0\u0026#39; option ip6assign \u0026#39;60\u0026#39; option gateway \u0026#39;192.168.101.2\u0026#39; # 填写为主路由地址 option dns \u0026#39;114.114.114.114 223.5.5.5\u0026#39; # 正常可用的DNS地址 按 ESC 输入 :wq 保存并退出。运行下面命令，重启网络使配置生效\n/etc/init.d/network restart 然后尝试 ping 主路由，ping 通则可使用\n1、关闭 / 不关闭副路由的 DHCP # 1.1、如果关闭，则使用 OpenWRT 的 DHCP\n好处：不需要修改链接设备的 DNS ，连上即可使用 OpenWRT 的功能\n坏处：对家里其他人连接到这台副路由器的设备也有影响\n1.2、如果不关闭，则不使用 OpenWRT 的 DHCP 好坏处自己衡量吧\n2、如果关闭路由器的 DHCP 功能 # Proxmox VE 虚拟机安装 OpenWrt 配置旁路由教程 - 喵斯基部落\n3、如果关闭 OpenWRT 的 DHCP 模式 # 三分钟搞定OpenWrt网关(旁路由)模式设置 小白必备教程 适用于N1及所有旁路由设备\n","date":"9 August 2022","externalUrl":null,"permalink":"/kvm_openwrt/","section":"文章列表","summary":"本文介绍了 KVM 安装 OpenWRT 作为旁路由的过程，并介绍了我的电脑环境配置。","title":"KVM 安装 OpenWRT 作为旁路由","type":"blog"},{"content":"","date":"9 August 2022","externalUrl":null,"permalink":"/slug/kvm_openwrt/","section":"Slug","summary":"","title":"Kvm_openwrt","type":"slug"},{"content":"","date":"9 August 2022","externalUrl":null,"permalink":"/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/","section":"文章标签列表","summary":"","title":"软路由","type":"tags"},{"content":"","date":"9 September 2021","externalUrl":null,"permalink":"/slug/markdown/","section":"Slug","summary":"","title":"Markdown","type":"slug"},{"content":"Markdown 是一种轻量级标记语言，旨在使文本的格式化更加简洁直观。以下是一些常用的 Markdown 语法及其示例。\n1. 标题 # Markdown 支持六级标题。使用 # 符号表示标题的级别，# 的数量表示标题的级别。\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 2. 段落和换行 # 段落通过一个或多个空行分隔。要在段落中插入换行符，可以在行尾添加两个或更多空格。\n这是一个段落。 这是另一个段落， 在这里插入换行符。 3. 粗体和斜体 # 粗体：使用 ** 或 __ 包围文本。 斜体：使用 * 或 _ 包围文本。 **这是粗体文本** __这也是粗体文本__ *这是斜体文本* _这也是斜体文本_ 4. 列表 # Markdown 支持无序列表和有序列表。\n无序列表：使用 *、+ 或 -。 有序列表：使用数字和点。 无序列表： * 项目 1 * 项目 2 * 子项目 1 * 子项目 2 有序列表： 1. 第一项 2. 第二项 1. 子项 1 2. 子项 2 5. 链接 # 插入链接使用 [文本](URL) 语法。\n[OpenAI](https://www.openai.com/) 6. 图片 # 插入图片使用 ![替代文本](图片 URL) 语法。\n![Markdown Logo](https://markdown-here.com/img/icon256.png) 7. 引用 # 引用使用 \u0026gt; 符号。\n\u0026gt; 这是一个引用 8. 代码 # 行内代码：使用反引号 ` 包围代码。 代码块：使用三个反引号 ``` 或者缩进四个空格。 行内代码：`console.log(\u0026#39;Hello, World!\u0026#39;)` 代码块： \\``` function greet() { console.log(\u0026#39;Hello, World!\u0026#39;); } \\``` 9. 表格 # 表格使用 | 符号分隔列，- 符号分隔表头和表体。\n| 列 1 | 列 2 | | ---- | ---- | | 数据 1 | 数据 2 | | 数据 3 | 数据 4 | 10. 分隔线 # 分隔线使用三个或更多的 -、* 或 _。\n--- *** ___ ","date":"9 September 2021","externalUrl":null,"permalink":"/markdown/","section":"文章列表","summary":"本文介绍了 Markdown 语法的基本用法，并提供了一些示例。","title":"Markdown 语法指南","type":"blog"},{"content":"","date":"24 August 2021","externalUrl":null,"permalink":"/slug/onedrive_directory_index/","section":"Slug","summary":"","title":"Onedrive_directory_index","type":"slug"},{"content":"我的 OneDrive 目录索引目前依赖两个项目\nonedrive-cf-index 部署在 CloudFlare Workers 上\nspencerwooo/onedrive-cf-index Deprecated, use new project 👇 JavaScript 1079 439 onedrive-vercel-index 部署在 Vercel 上\nspencerwooo/onedrive-vercel-index OneDrive public directory listing, powered by Vercel and Next.js TypeScript 3024 3555 vercel 的速度没有 cf 的快，但是 vercel 部署简单，预览文件功能轻量快速。\n部署指南 # 参考 README.md\ncf-index 部署 # 准备工作（CloudFlare Workers 设置） # 1、导入并 clone 仓库\nonedrive-cf-index/README-CN.md at main · spencerwooo/onedrive-cf-index\n复制仓库的 url 地址，并导入成你的 GitHub 私人仓库（不要直接 fork 仓库），在你的电脑上使用 git clone https://github.com/你的仓库地址 命令来下载到本地\n2、npm 安装依赖\n进入到刚刚拉取的文件夹，使用 npm 安装依赖\n# 安装 CloudFlare Workers 官方编译部署工具 npm i @cloudflare/wrangler -g # 使用 npm 安装依赖 npm install # 使用 wrangler 登录 CloudFlare 账户 wrangler login # 使用这一命令检查自己的登录状态 wrangler whoami 打开 https://dash.cloudflare.com/login 登录 CloudFlare，选择自己的域名，再向下滚动一点，我们就能看到右侧栏处我们的 account_id 以及 zone_id 了。 同时，在 Workers -\u0026gt; Manage Workers -\u0026gt; Create a Worker 处创建一个 DRAFT worker。\n修改我们的 wrangler.toml：\nname：就是我们刚刚创建的 draft worker 名称 account_id：我们的 Cloudflare Account ID； zone_id：我们的 Cloudflare Zone ID 3、创建叫做 BUCKET 的 Cloudflare Workers KV bucket\n# 创建 KV bucketwrangler kv:namespace create \u0026#34;BUCKET\u0026#34; # ... 或者，创建包括预览功能的 KV bucketwrangler kv:namespace create \u0026#34;BUCKET\u0026#34; --preview 修改 wrangler.toml 里面的 kv_namespaces：\nkv_namespaces：我们的 Cloudflare KV namespace，仅需替换 id 和（或者）preview_id 即可。如果不需要预览功能，那么移除 preview_id 即可。 生成 OneDrive API 令牌 # 1、访问此 URL 创建新的 Blade app： Microsoft Azure App registrations（普通版 OneDrive） 或 Microsoft Azure.cn App registrations（OneDrive 世纪互联版本）\n名称可以自定义 受支持的帐户类型选择 “任何组织目录(任何 Azure AD 目录 - 多租户)中的帐户和个人 Microsoft 帐户(例如，Skype、Xbox)” 重定向 URI 填写 http://localhost 确认无误后点击 “注册”\n2、配置 API 权限\n打开 “API 权限” 面板，选择 “Microsoft Graph”，选择 “委托的权限”，并搜索 offline_access, Files.Read, Files.Read.All 这三个权限，选择这三个权限，并点击 “添加权限”\n3、查看 “应用程序客户端ID”\n4、生成 “客户端密码”\n打开 “证书和密码” 面板，点击 新客户端密码，点击 “添加” 并复制 “值” 并保存下来 （仅有此一次机会）\n5、生成 refresh_token\n确保你已经知道以下凭证：\nclient_id 即 应用程序客户端ID client_secret 即 客户端密码 在本机（需要 Node.js 和 npm 环境）上面执行如下命令：\nnpx @beetcb/ms-graph-cli@next -s -l CN 根据你自己的情况选择合适的选项，并输入我们上面查看复制的一系列令牌配置等，其中 redirect_url 可以直接回车。\n6、最后，在我们的 OneDrive 中创建一个公共分享文件夹，比如 /Public 即可。\n将应用部署到 CloudFlare Workers 上 # 进入到准备工作时拉取的文件夹\n1、修改 src/config/default.js：\nclient_id：刚刚获取的 OneDrive 应用客户端ID； base：之前创建的公共分享文件夹 即 /Public； 2、使用 wrangler 添加 Cloudflare Workers 环境变量（有关认证密码的介绍请见 🔒 私有文件夹）：\n在文件夹所在终端中输入：\n# 添加我们的 refresh_token 和 client_secret wrangler secret put REFRESH_TOKEN # ... 并在这里粘贴我们的 refresh_token wrangler secret put CLIENT_SECRET # ... 并在这里粘贴我们的 应用客户端ID wrangler secret put AUTH_PASSWORD（可选） # ... 在这里输入我们自己设置的认证密码 3、编译与部署\n我们可以使用 wrangler 预览部署：\nwrangler preview 如果一切顺利，我们即可使用如下命令发布 Cloudflare Worker：\nwrangler publish 我们也可以创建一个 GitHub Actions 来在每次 push 到 GitHub 仓库时自动发布新的 Worker，详情参考： main.yml。\n如果想在自己的域名下部署 Cloudflare Worker，请参考： How to Setup Cloudflare Workers on a Custom Domain。\n4、样式、内容的自定义\n我们可以更改默认「着落页面」，直接修改 src/folderView.js 中 intro 的 HTML 即可； 我们也可以更改页面的 header，直接修改 src/render/htmlWrapper.js 即可； 样式 CSS 文件位于 themes/spencer.css，可以根据自己需要自定义此文件，同时也需要更新 src/render/htmlWrapper.js 文件中的 commit HASH； 我们还可以自定义 Markdown 渲染 CSS 样式、PrismJS 代码高亮样式，等等等。 ","date":"24 August 2021","externalUrl":null,"permalink":"/onedrive_directory_index/","section":"文章列表","summary":"本文介绍了如何搭建 OneDrive 目录索引，并详细介绍了部署过程。","title":"搭建 OneDrive 目录索引","type":"blog"},{"content":" 此页面是本站的关于页面\n做技术的黑客心态加上开放共进的态度是成长和越过高山幽谷的秘籍！ 你好！欢迎来到我的个人网站。我是一名热爱技术和创造的人，希望通过我的技能和知识为社会带来积极的影响。\n说明 # 本站使用 Hugo 构建，大部分页面模板来自 大大的小蜗牛 的网站\n通过 GitHub Actions 部署至 GitHub Pages\n主题使用的是 Blowfish\n嘀咕页面依赖 Mastodon 实例： https://mastodon.social/@qlAD\n观影页面依赖 NeoDB： https://neodb.social\n评论系统依赖 Giscus： https://giscus.app\n联系我 # 邮件: qlad.adgk.1024@gmail.com 感谢你的访问！\n","date":"14 April 2006","externalUrl":null,"permalink":"/about/","section":"关于","summary":"\u003cblockquote\u003e\n\u003cp\u003e此页面是本站的关于页面\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv style=\"display: flex; align-items: center;\"\u003e\n    \u003cimg src=\"/avatar.webp\" style=\"margin-right: 10px;\"\u003e\n    \u003cspan\u003e做技术的黑客心态加上开放共进的态度是成长和越过高山幽谷的秘籍！\u003c/span\u003e\n\u003c/div\u003e\n\u003cp\u003e你好！欢迎来到我的个人网站。我是一名热爱技术和创造的人，希望通过我的技能和知识为社会带来积极的影响。\u003c/p\u003e","title":"关于","type":"sample"},{"content":" 本站 ChatGPT 所有原创文章如下\n","externalUrl":null,"permalink":"/authors/chatgpt/","section":"作者列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站 ChatGPT 所有原创文章如下\u003c/p\u003e\n\u003c/blockquote\u003e","title":"ChatGPT","type":"authors"},{"content":" 本站 qlAD 所有原创文章如下\n","externalUrl":null,"permalink":"/authors/qlad/","section":"作者列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站 qlAD 所有原创文章如下\u003c/p\u003e\n\u003c/blockquote\u003e","title":"qlAD (站长)","type":"authors"},{"content":"","externalUrl":null,"permalink":"/go/","section":"Redirect","summary":"","title":"Redirect","type":"sample"},{"content":"注1：同一文章可能包含多个分类。\n","externalUrl":null,"permalink":"/stats/","section":"博客统计","summary":"\u003cp\u003e注\u003csup\u003e1\u003c/sup\u003e：同一文章可能包含多个分类。\u003c/p\u003e","title":"博客统计","type":"sample"},{"content":" 此页面是一个微博客子栏目。主要是区别于博客长文的自言自语。信息流来自 Mastodon ，时间线工具： Mastodon embed timeline 。\n","externalUrl":null,"permalink":"/mastodon/","section":"嘀咕","summary":"\u003cblockquote\u003e\n\u003cp\u003e此页面是一个微博客子栏目。主要是区别于博客长文的自言自语。信息流来自 \n\u003ca href=\"/go/?target=aHR0cHM6Ly9tYXN0b2Rvbi5zb2NpYWwvQHFsQUQ%3d\" target=\"_blank\" rel=\"noopener noreferrer\" \u003eMastodon\u003c/a\u003e ，时间线工具：\n\u003ca href=\"/go/?target=aHR0cHM6Ly9naXRsYWIuY29tL2lkb3RqL21hc3RvZG9uLWVtYmVkLXRpbWVsaW5l\" target=\"_blank\" rel=\"noopener noreferrer\" \u003eMastodon embed timeline\u003c/a\u003e 。\u003c/p\u003e","title":"嘀咕","type":"sample"},{"content":" 本站所有文章标签如下（包括原创和转载）\n","externalUrl":null,"permalink":"/tags/","section":"文章标签列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站所有文章标签如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e","title":"文章标签列表","type":"tags"},{"content":" 本站所有文章分类如下（包括原创和转载）\n","externalUrl":null,"permalink":"/categories/","section":"文章分类列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站所有文章分类如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e","title":"文章分类列表","type":"categories"},{"content":" 本站所有文章如下（包括原创和转载）\n","externalUrl":null,"permalink":"/blog/","section":"文章列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站所有文章如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e","title":"文章列表","type":"blog"},{"content":" 本站所有系列文章如下（包括原创和转载）\n","externalUrl":null,"permalink":"/series/","section":"系列文章列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站所有系列文章如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e","title":"系列文章列表","type":"series"},{"content":" 本站文章的所有创作者如下（包括原创和转载）\n","externalUrl":null,"permalink":"/authors/","section":"作者列表","summary":"\u003cblockquote\u003e\n\u003cp\u003e本站文章的所有创作者如下（包括原创和转载）\u003c/p\u003e\n\u003c/blockquote\u003e","title":"作者列表","type":"authors"}]